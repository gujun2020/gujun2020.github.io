<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>强化学习（七）Double DQN</title>
    <link href="/2021/10/21/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89Double-DQN/"/>
    <url>/2021/10/21/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89Double-DQN/</url>
    
    <content type="html"><![CDATA[<p>在这一节，我们将用CartPole-v0作为环境做试验，并介绍DQN的训练的技巧和DQN其中一个最重要的变种DQN：Double DQN。</p><span id="more"></span><p>在上一章，我们虽然我们用上了DQN，希望解决连续状态空间的问题，但我们的环境仍然是用FrozenLake-v0。</p><p>虽然证明了我们可以深度神经网络的方式，但多少有点英雄无用武之地的感觉。 在这一节，我们将用CartPole-v0作为环境做试验，并介绍DQN的训练的技巧和DQN其中一个最重要的变种DQN：Double DQN。</p><h2 id="CartPole-v0说明"><a href="#CartPole-v0说明" class="headerlink" title="CartPole-v0说明"></a>CartPole-v0说明</h2><p>在介绍算法之前，我们先了解一下CartPole这个游戏的特点。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89Double-DQN/008i3skNly1gvn5bh3y9cj60d808qweb02.jpg"></p><p>CartPole-v0游戏有一个车子，车子上面立一支杆。智能体的任务是，让车子必须左右移动来保持车上的杆保持竖直。如果杆子倾斜超过12度，则游戏结束。</p><p>每坚持一帧，智能体能获得 1 reward，如果能获得200reward，那么游戏结束。如果杆子掉下来，游戏失败。继续下一轮游戏。</p><p>我们之前说过，CartPole的状态是连续型的状态，所以我们可以用几个状态特征来表示。</p><p>状态特征： </p><ul><li>- 车子位置：[-2.4,2.4] </li><li>- 车子速度：[-Inf,Inf] </li><li>- 杆子角度：[-41.8,41.8] </li><li>- 杆子（顶端）速度：[-Inf,Inf]</li></ul><p>智能体可以决定做两个动作： </p><ul><li>- 0： 把车子往左拉 </li><li>- 1： 把车子往右拉</li></ul><p>Reward：除最终最终状态外，所有状态都能获得1reward</p><p>最终状态条件： </p><ol><li>杆子角度&gt;= ±12° </li><li>车子位置&gt;= ±2.4 </li><li>坚持200步</li></ol><p>所以CartPole游戏其实就是让智能体学会玩杂耍，坚持时间越长获得奖励越多。</p><h2 id="经验回放-Experience-replay"><a href="#经验回放-Experience-replay" class="headerlink" title="经验回放(Experience replay)"></a>经验回放(Experience replay)</h2><p>在强化学习中，有一个问题始终绕不过。训练网络数据采集总是太慢。</p><p>当然这个慢是对比网络训练的速度。在强化学习中，网络训练经过GPU的加速，比起游戏来是快很多的。所以训练的瓶颈一般在<strong>智能体跟环境互动</strong>的过程中。</p><p>如果我们能把互动过程中的数据，都存起来，当数据足够多的时候，再训练网络，那么就快很多了。</p><p>**经验回放(Experience replay)**就是实现这样的过程:</p><p>我们把每一步的s，选择的a，进入新的状态s’，获得的奖励r，新状态是否为终止状态。我们把数据都全部存在一个叫<strong>回放缓存</strong>的地方(replay buffer)。</p><p>当智能体与环境互动期间，就会不断产生这样一条一条数据。 数据1： 数据2： 数据3： ….</p><p>当数据量足够，例如<strong>达到我们设定一个batch的大小</strong>，我们便从中抽出一个batch大小的数据，把这笔数据一起放入网络进行训练。</p><p>训练之后我们继续进行游戏，继续把新产生的数据添加到<strong>回放缓存</strong>里…</p><p>就这样，我们每次都随机抽出一个batch大小的数据训练智能体。这样，以前产生的数据同样也能用来训练数据了, 效率自然更高。</p><p>使用经验回放除了使训练更高效，同时也减少了训练产生的过度拟合的问题。</p><p><strong>过度拟合</strong>，放到人身上就是过度依赖局部经验了。</p><p>就像孩子发现爸爸有胡子，就认为所有男人都有胡子一样。</p><p>同样，在有监督学习中，如果只给模型看少量的几张图，并且告诉模型这是猫。这样模型就只会从这几张图学习到猫的特点，而更多的猫模型可能就不认得了。我们说这就是过度拟合造成的，导致模型不够健壮。</p><p>所以健壮的模型，和人一样，见识丰富了就不会落入局部经验的圈套了。</p><p>经验回放具体的做法有很多，将会在稍后的示例代码中展示其中一种。</p><h2 id="固定Q目标-Fixed-Q-targets"><a href="#固定Q目标-Fixed-Q-targets" class="headerlink" title="固定Q目标(Fixed Q-targets)"></a>固定Q目标(Fixed Q-targets)</h2><p>也许在上一篇DQN的介绍中，有同学已经会有这样一个疑问。</p><p>DQN的目标: <strong>gamma * maxQ(s’) + r</strong></p><p>目标本身就包含一个Q网络，这样没有问题吗？</p><p>理论上是没有问题的，但，这样会造成Q网络的学习效率比较低，而且不稳定。</p><p>如果<strong>把训练神经网络比喻成射击游戏</strong>，在target中有Q网络的话，就相当于在射击一个移动靶，因为每次射击一次，靶就会挪动一次。相比起固定的靶，无疑加上了训练的难度。</p><p>那怎么解决这个问题呢？既然现在是移动靶，那么我们就把它弄成是固定的靶，先停止10秒。10秒后挪动靶再打新的靶。这就是Fixed Q-targets的思路。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89Double-DQN/008i3skNly1gvn5yi2qlrj60lx0bejru02.jpg"></p><p>在实做的时候，其实和原来的DQN一样，唯一不同点是，我们用两个Q网络：</p><p>一个是原来的Q网络，用于估算Q(s);</p><p>另外一个叫targetQ网络, targetQ自己并不会更新，也就是它在更新的过程中是固定的，用于计算更新目标。</p><p>y = r + gamma * max(targetQ(s’))</p><p>我们进行N次更新后，就把新Q的参数赋值给旧Q。</p><p>同学们可以试试，利用以上来个技术来优化自己的程序。如果有难度，也先别着急。在下面的doubleDQN的示例代码中，用上以上两个技术。DoubleDQN和DQN的差别很小，其中的差别我也会提出来让大家对比。</p><h2 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h2><p>DQN有一个显著的问题，就是DQN估计的Q值往往会偏大。这是由于我们Q值是以下一个s’的Q值的最大值来估算的，但下一个state的Q值也是一个估算值，也依赖它的下一个state的Q值…，这就导致了Q值往往会有偏大的的情况出现。</p><p>我们从同一个s’进行试探性出发，计算某个动作的Q值。然后和DQN的记过进行比较就可以得出上述结论。</p><p>这种欺上瞒下的做法，实在令人恼火。于是有人想到一个互相监察的想法。</p><p>这个思路也很直观。如果只有一个Q网络，它不是经常吹牛嘛。那我就用两个Q网络，因为两个Q网络的参数有差别，所以对于同一个动作的评估也会有少许不同。我们选取评估出来较小的值来计算目标。这样就能避免Q网络吹牛的情况发生了。</p><p>另外一种做法也需要用到两个Q网络。Q1网络<strong>推荐</strong>能够获得最大Q值的动作；Q2网络计算这个动作在Q2网络中的Q值。</p><p>恰好，如果我们用上Fixed Q-targets，我们不就是有两个Q网络了吗？</p><p>所以你可以看到，这个优化在DQN上很容易实现。这就是doubleDQN和DQN的唯一的变化。</p><p>具体的实现，请看代码分析。（ 由于tensorflow提供的示例代码对于新手来说有点复杂，我另外写了一个代码以供说明。）</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>流程： 如果已经熟悉了之前DQN的代码，那么我们主流程就很容易明白了。我们现在主要关注 Experience replay。</p><p>我把不相关的代码隐藏掉，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self,episode</span>):<br>        ...<br>        <span class="hljs-keyword">for</span> ep <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(episode):   <span class="hljs-comment">#1</span><br>            s = self.env.reset()<br>            ...<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                a = self.get_action(s)    <span class="hljs-comment">#2</span><br>                s_,r,done,_ = self.env.step(a)  <span class="hljs-comment">#3</span><br>                self.remember(s, a, s_, r, done)   <span class="hljs-comment">#4</span><br>                s = s_<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.memory)&gt;self.batch:<br>                    loss = self.update_Q_network()   <span class="hljs-comment">#5</span><br>                    ....<br>                    <span class="hljs-keyword">if</span> (step+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:             <span class="hljs-comment">#6</span><br>                        self.update_epsilon()<br>                        self.update_target_Q()<br></code></pre></td></tr></table></figure><ol><li>我们开始一次游戏，用self.env.reset()把状态设置成初始状态。</li><li>把代入get_action函数，获得action。get_action函数采用epsilon-greedy方法，在之前已经讲述过，这里就不再赘述。</li><li>把action代入环境，获得下一个状态s_,奖励r，结束标记done，和info（由于我们没有用到相关的info，所以我们用_,忽略掉）</li><li>我们用 self.remember(s, a, s_, r, done)， 把这个过程都记录到self.memory</li><li>如果我们的记录足够，那么我们我们就进行更新。</li><li>我们设置一个间隔，每更新5步，就更新target_Q，并更新epsilon</li></ol><p>从上面我们可以看成，doubleDQN其实和DQN的流程没什么不同，不过我们加上了一步，把智能体和环境互动产生的数据remember下来，用于经验回放。</p><p>那具体怎样把数据保存起来呢？我们可以看一下。</p><p>首先，保存我们先得有容器。容器的选择有很多，通常是列表。在示例代码中用了双端deque，因为<strong>它的数据结构能够快速随机访问其中任何一个元素，利于我们随机获取其中的数据用于更新</strong>。</p><p>我们把deque最大值为2000，当我们插入元素超过最大值，那么就会删除最初插入的元素。这个过程deque自动进行，不需要我们手动管理，非常方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>...<br>self.memory = deque(maxlen=<span class="hljs-number">2000</span>) <br></code></pre></td></tr></table></figure><p>准备工作我们已经完成了，我们看remember函数，我们把需要存储的数据s, a, s_, r, done传入，我们先用data把数据打包成一个元组，memory.append(data)，插入到队列中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">remember</span>(<span class="hljs-params">self, s, a, s_, r, done</span>):<br>    data = (s, a, s_, r, done)<br>    self.memory.append(data)<br></code></pre></td></tr></table></figure><p>整个结构如下图：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89Double-DQN/008i3skNly1gvn7ecebhwj606i0380sr02.jpg"></p><p>现在我们每次有state转换，都会被存储到memory这个队列中。当数据足够，例如大于batchsize，那么我们就从队列中，随机抽取batchsize个data，用于更新。</p><p>但buffer是不能直接更新的，需要最好先整理更新目标。我们看process_data前半段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>(<span class="hljs-params">self</span>):<br>    data = random.sample(self.memory, self.batch)<br>    s = np.array([d[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data])<br>    a = [d[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data]<br>    s_ = np.array([d[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data])<br>    r = [d[<span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data]<br>    done = [d[<span class="hljs-number">4</span>] <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data]<br></code></pre></td></tr></table></figure><p>关注两点： </p><p>\1. random.sample(self.memory, self.batch) random.sample，就是从队列中，随机抽出一定个数的数据。 例如抽取了红色部分的数据，这些新数据组成data，这部分数据就是用于这一次更新。</p><p>\2. 用[d[0] for d in data]形式处理data。 我们构造一个循环，来访问data里面的一列数据。所以这里的d，其实相当于在memory函数里面的data，也就是每一步产出数据构成的元组。我们用d[0]，表示这个元组的第一个元素，也就是s。外面用中括号括起来，表示把这些数据构成一个数组。</p><p>这里s和s_是需要输入到神经网络的，所以我们把数组，变成array。</p><p>下面就是我们这一篇的重点：如何用双Q网络更新和计算target。</p><p>在代码中，我们使用两个网络：</p><ul><li>Q_network用于训练更新。</li><li>target_Q_network 是固定网络，用于计算target。</li></ul><p><em>注意: 如果用到了tensorlayer，建立网络后，这个网络是否用于训练，我们需要用一行代码说明，否则将会报错。例如</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">self.Q_network = self.get_model()<br>self.Q_network.train()    <span class="hljs-comment"># 这个网络是可以训练的。</span><br>self.target_Q_network = self.get_model()<br>self.target_Q_network.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 这个网络是不可以训练的。</span><br></code></pre></td></tr></table></figure><p>经过一定的episode之后，再把Q_network的的参数，赋值给target_Q_network。</p><p>在赋值的时候，我们可以通过一个循环，逐个用assign()函数对模型的参数进行赋值。</p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Double DQN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习</title>
    <link href="/2021/10/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/10/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2021/10/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/10/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>强化学习（六）深度强化学习</title>
    <link href="/2021/10/19/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/10/19/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>从这篇开始，我们将会进入<strong>深度</strong>强化学习。所谓<strong>深度</strong>强化学习，其实就是用<strong>深度神经网络</strong>辅助强化学习。</p><span id="more"></span><p>但有同学可能会对深度神经网络还不是很了解。这里强烈推荐同学看一下吴恩达老师的课程。对于入门同学非常友好。</p><p>但如果同学希望对神经网络有一个梗概的了解，那可以看看本篇。本篇将以<strong>手写数字识别</strong>作为示例，看一下如何直观理解深度神经网络。</p><h2 id="神奇的深度神经网络"><a href="#神奇的深度神经网络" class="headerlink" title="神奇的深度神经网络"></a>神奇的深度神经网络</h2><p>不知道大家有没有发现，在日常生活中，我们明明知道一些东西和另外一些东西是有关联的，但我们却无法描述。</p><p>举个例子： 手写数字的辨识：我们明明知道一个手写数字是什么，但我们却没有办法用语言描述。</p><p>数字8</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlsu1e2msj60ee03qq2x02.jpg"></p><p>不同人写的数字8，长得都很像，所以大家能够一眼分辨出来8长的是什么样子。 但具体来说，每个8的样子都长的不太一样：虽然我们知道8由两个圈圈组成，一上一下，但精确到某个像素应该白色还是黑色？圈圈的大小如何？一定要完美的圈圈才是数字8吗？这些问题我们却很难回答。</p><p>再举个例子，语音翻译： 我们希望记录人们的语音，然后翻译为对应的文字。 其实我们明知道语音和文字之间是有关系的，不同人对同样的文字发音不完全相同，但我们人类是能识别并翻译出来。 我们确没有办法精确描述某个发音（声纹）准确获得对应的文字。</p><p>不能描述的后果很严重，这以为着我们没有办法用代码的形式把规则写下来。也就意味着，我们不能把这部分工作<strong>自动化</strong>。</p><p>这就是为什么我们的机器能够替代体力劳动的工作，但不能替代脑力劳动。这是因为脑力劳动的工作，相对体力劳动要更复杂。</p><p>但深度学习出现后，改变了这个想法。</p><h2 id="超简深度神经网原理"><a href="#超简深度神经网原理" class="headerlink" title="超简深度神经网原理"></a>超简深度神经网原理</h2><p>假如，我们明明知道X，y有关系，那么我们不妨先设这个关系可以通过函数Magic(X)获得。也就是说Magic(X)=y。</p><p>这在手写数字识别中，X就是需要识别的图片，y就是识别出来的数字分类。</p><p>我们的任务就是需要求这个Magic函数。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlsv928lvj60dy04qt8n02.jpg"></p><p>在传统方法，我们需要写一些系列规则来表达这个函数。但在深度神经网络，我们会改变一下思路。</p><p>现在我们假设有另外一个函数Magic’(),这个函数是由深度神经网络构成。至于是怎样构成，我们后面再说。</p><p>在刚开始的时候，很明显Magic’(X) 并不等于y，例如输入手写图片8，Magic’()计算后，认为数字8只有20%，但数字9有40%。</p><p>…但这没所谓，因为这是刚开始。我们的任务是让Magic’(X)产生的结果y’ 和 y尽量接近。</p><p>y’和真实y之间的差距，我们叫损失，也就是loss。有时候我们也会把y称为目标(target)，因为我们的任务就是让Magic’(X)越来越靠近这个目标。</p><p>衡量loss的方法有很多，定义不同loss对神经网络学习有着重大差别，这个话题太大，我们暂时不展开。</p><p>loss越大，表示和目标差距越远；loss越小，表示和目标越近，当小到一定值，那么我们就可以认为Magic’(X)和我们要的magic(X)函数非常接近，因为我们可以通过Magic’(X)计算出y。</p><p>当我们有许许多多这样的y，经过许许多多轮后。Magic’就越来越贴近Magic。也就是说X和y之间的关系就能越来越好地表达出来。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlswizt2mj60kb0du74y02.jpg"></p><p>最后，我们就说这个Magic函数，学习到某种能力。</p><p>当然，上面的描述实在太简化，这个Magic函数能否训练出来，我们选取的loss函数，神经网络的结构，数据的大小，质量等很多很多学问。如果想入门，再次强烈推荐吴恩达老师的课程。</p><p>但我们目前把关注点放在强化学习的算法，我们不妨先把神经网络看成一个万能的Magic函数。我们后续在分析代码的时候，会把一些简单的原理介绍给大家。</p><h2 id="放大镜下深度神经网络"><a href="#放大镜下深度神经网络" class="headerlink" title="放大镜下深度神经网络"></a>放大镜下深度神经网络</h2><p>为了用代码构建深度神经网络，我们有必要解剖一下，深度神经网络到底是怎样构造的。</p><p>现在我们可以把深度神经网络的Magic函数，看成是一个数据加工厂。而X就是要进行加工的数据。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlsygmj15j61400kr75s02.jpg"></p><p>为了让这个数据加工厂运行得更快，通常我们需要把要加工的数据X变得更‘标准’一些。</p><p>例如图片的尺寸大小，有多少通道的颜色等等，然后分批(一般称为batch)，输入工厂。</p><p>在输入工厂的时候，会有一个‘大门’，我们称为输入层，去检查数据是否已经按照工厂的标准整理好。</p><p>数据工厂里有很多车间，按照流水线排列。和一般的自动化车间一样，我们需要定义好这个车间的操作标准。</p><p>我们一般称这些车间叫<strong>层</strong>。这些层都已经封装好在tensorflow、tensorlayer、pytorch等里面了。常用的层包括：Dense、Conv2D、LSTM、Reshape、Flatten等。</p><p>最终，数据工厂会把原数据X，加工成产品y’(也叫做：logits)。从源数据加工成产品的过程，我们叫<strong>正向传播</strong>。</p><p>但产品y’是否是一个合格的产品，我们还需要我们真正的y(也叫做:lables)作为标准去鉴定。我们把鉴定出来的差距就是loss。</p><p>工厂根据鉴定结果，以<strong>梯度下降</strong>的方式，<strong>反向传递</strong>给每个车间，告诉车间要如何调整各自的参数，让源数据和产出y’能够对应起来。</p><p>经过N个批次（batch）的数据输入，然后鉴别，工厂调整。最后工厂就能达到我们的生产标准了。也就是说magic函数已经被训练好了。</p><h2 id="构建深层神经网络"><a href="#构建深层神经网络" class="headerlink" title="构建深层神经网络"></a>构建深层神经网络</h2><p>我们以fashion_mnist为例，看看我们应该怎样构建深层的神经网络。</p><p><em>其实构建深层神经网络的方法是多种多样的，有许多更为简便的方式，例如keras。 在这里，我们以tensorlayer作为例子，主要有两个考量： 1. 在我们往后的示例代码，基本上都用tensorlayer，我们可以借此熟悉一下； 2. 这里用上了自动求导的方式，会更加灵活，也让大家看清楚这个基本流程。</em></p><h3 id="Fahsion-MNIST-数据介绍"><a href="#Fahsion-MNIST-数据介绍" class="headerlink" title="Fahsion_MNIST 数据介绍"></a>Fahsion_MNIST 数据介绍</h3><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlt6gjr5kj61400k00xo02.jpg"></p><p>Fashion MNIST是一个非常适合入门，又好玩的数据集，做完之后保证成就感满满。</p><p>一般来说，数据集包含了训练集和测试集。如图：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlt6zer2sj609z037glr02.jpg"></p><p>在有监督学习下，一般我们会把数据分为训练集和测试集。就如名字一样，训练集就是用来训练模型的，测试集就是为了测试模型是否真的管用的。</p><p>其中每种数据集合中包含了图片和标签，例如：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlt8ghi59j607n07faa402.jpg"></p><p>图片，对应的标签是[鞋子]分类。</p><p>当然并不是所有的数据集，都是图片，也有可能是数据。例如天气预测，数据可能是以往的天气数据，例如前一天的气温，气压，湿度等。标签就是当天的天气。</p><p>在Fashion MNIST里，训练集和测试集里面的数据，都已经为大家对应好了。</p><p>现在我们要训练一个神经网络，用训练集的数据，学习根据图像，去判别这是什么服装类型。然后把这个神经网络用在测试集上，看看正确率有多少。</p><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a><strong>加载数据集</strong></h3><p>现在，我们可以用这么一个语句，来加载Fashion MNIST数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(train_images, train_labels), (test_images, test_labels) = keras.datasets.fashion_mnist.load_data()<br></code></pre></td></tr></table></figure><p>train_images：训练集图片 train_labels：训练集标签 test_images：测试集图片 test_labels：测试集标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(train_images.shape)<br><span class="hljs-built_in">print</span>(train_labels.shape)<br><span class="hljs-built_in">print</span>(test_images.shape)<br><span class="hljs-built_in">print</span>(test_labels.shape)<br></code></pre></td></tr></table></figure><p>打印结果：</p><p>(60000, 28, 28) (60000,) (10000, 28, 28) (10000,)</p><p>也就是说 训练集含有：60,000张图像，对应60,000个标签； 测试集含有：10,000张图像对应10,000个标签。</p><p>而每张图的大小为 28 x 28。</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>注意：在神经网络的相关编程里面，有两个东西大家必须要留意，一个是数据的shape，一个是数据的type。</p><p>我们输入神经网络的数据，往往不是一个单一的数值。而是很多数值组成的形状。</p><p>例如一张图28x28大小灰度图。从数据层面来看它是由28x28个数值表示表示出来的。那么我们说这个数据的shape就是28x28。</p><p>我们说一张灰度图是二维的，也有三维数据，例如彩色图片，是由RGB三层数据表示。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvltam1i55j60ft08smxp02.jpg"></p><p>当然，也有更高纬度的数据。数据在输入到神经网络之前，都要整理好形状。</p><p>而我们说的数据的type，是指数据的每一个数值的类型。一般来说，我们会用32位浮点数(float32)。</p><p>在Fashion_Mnist每张图的大小为28x28，每个像素值处于0到255之间。</p><p>因为我们的像素，除以0到255之间，因此我们需要除以255，让数据保持在0-1之间。</p><h3 id="建立深度神经网络的一般步骤"><a href="#建立深度神经网络的一般步骤" class="headerlink" title="建立深度神经网络的一般步骤"></a>建立深度神经网络的一般步骤</h3><h4 id="1、创建一个深度神经网络和优化器"><a href="#1、创建一个深度神经网络和优化器" class="headerlink" title="1、创建一个深度神经网络和优化器"></a>1、<strong>创建一个深度神经网络和优化器</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model</span>(<span class="hljs-params">inputs_shape</span>):<br>    inputs = tl.layers.Input(inputs_shape)<br>    cnn = tl.layers.Conv2d(n_filter=<span class="hljs-number">32</span>,filter_size=(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),strides=(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),act=<span class="hljs-string">&#x27;relu&#x27;</span>,padding=<span class="hljs-string">&#x27;SAME&#x27;</span>)(inputs)<br>    flatten = tl.layers.Flatten()(cnn)<br>    fc = tl.layers.Dense(n_units=<span class="hljs-number">128</span>, act=<span class="hljs-string">&#x27;relu&#x27;</span>)(flatten)<br>    outputs = tl.layers.Dense(n_units=<span class="hljs-number">10</span>,act=tf.nn.softmax)(fc)<br>    <span class="hljs-keyword">return</span> tl.models.Model(inputs=inputs, outputs=outputs)<br></code></pre></td></tr></table></figure><p>这里，我们采用的是函数式的方式建立深度神经网络。</p><p>我们之前讲过，神经网络的层，就相当于一个流水线工厂的车间，每个车间独立承担了对数据的一个操作。</p><p>inputs = tl.layers.Input(inputs_shape) 输入层相当于工厂的大门，检测输入数据是否符合工厂定义的标准。在Fashion MNIST中，我们的输入层需要接受一个batch大小的数据，每个数据是28 x 28 大小。batch大小我们暂时不设定，可以预留，我们用None表示。所以，我们的imputs_shapes=[None,28,28]</p><p>flatten = tl.layers.Flatten()(inputs) flatten层，我们需要把这28 x 28像素的图，变成一个长条形的数据，以方便后面接入全连接层。所以我们用上Flatten层，把数据变成[None,784]</p><p>fc = tl.layers.Dense(n_units=128, act=’relu’)(flatten) 现在我们加上全连接层，全连接层有128个单元，和原来的784个单元连接。在前面inputs和flatten两层，我们并没有对数据内容进行加工。而Dense是一种对数据内容进行计算的操作。</p><p>outputs = tl.layers.Dense(n_units=10,act=tf.nn.softmax)(fc) 在输出层，我们同样用上全连接层，输出10个单元，对应我们需要输出的10个分类，并用上softmax作为激活函数。</p><p>细心读代码的同学可能已经明白，以fc层为例：代码前一段：tl.layers.Dense(n_units=128, act=’relu’)是相当于车间。后面(flatten)是上一层车间产出的结果。函数式的模型定义方式，就是把上一层的输出，放入到输入，从而连成一条数据的流水线。</p><p>tl.models.Model(inputs=inputs, outputs=outputs) 流水线都定义好了，我们还需要一行代码，定义好工厂。工厂的定义很简单，只需要把工厂的大门和输入定义好就可以了。</p><h4 id="2、开始训练"><a href="#2、开始训练" class="headerlink" title="2、开始训练"></a>2、开始训练</h4><p>在训练的时候，我们会用到tensorflow2.0的<strong>自动求导机制</strong>。</p><p>我们先定义梯度带，并在梯度带中，描述数据从源数据开始到产品logits的，然后通过loss函数，求loss的全过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<br>     logits = network(images)<br>     loss = tf.losses.sparse_categorical_crossentropy(labels,logits)<br></code></pre></td></tr></table></figure><p>loss函数的定义是非常高深的学问，幸好，常用的loss函数已经被提取成工具，对于新手的我们只需要按需使用即可。</p><p>常用的loss函数有4个，在使用之前我们需要先考虑，我们在解决的是分类问题还是回归问题。 <strong>分类问题</strong>就是把原数据按照标签分类的任务： 一种是像我们正在解决的Fashion MNIST，是要分成多个类别的。这时候我们一般sparse_categorical_crossentropy 如果只需要分两类，那么我们可以用。 sigmoid_cross_entropy_with_logits</p><p><strong>回归问题</strong>是试图从凌乱的数据中寻着规律的问题。 虽然不太准确，但大家可以想象一下：我们的神经网络在产生一个曲线，神经网络在训练的时候扭动曲线（或者是曲面或者是更高纬度的东西），去连接每一个数据点。</p><p>如果你不清楚，很简单，你发现不是分类问题，那么一般来说就是回归问题。</p><p>对于回归问题，我们可以MSE均值方差。 loss = tf.reduce_mean(tf.square(logits, labels))</p><p>我们都定义loss的计算过程，就可以利用梯度带自动求导了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">grads = tape.gradient(loss, network.trainable_weights)<br>optimizer.apply_gradients(<span class="hljs-built_in">zip</span>(grads,network.trainable_weights))<br></code></pre></td></tr></table></figure><p>第一行，我们是用梯度带求导。获得对网络中每个参数的导数。 第二行，我们用优化器，对参数进行求导。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = tf.optimizers.Adam()<br></code></pre></td></tr></table></figure><p>而优化器（optimizer），我们在之前定义了使用Adam()，</p><p>这行代码可以变化的不多，如果大家不明白，可以先记起来。</p><h4 id="3-展示训练效果"><a href="#3-展示训练效果" class="headerlink" title="3. 展示训练效果"></a>3. 展示训练效果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>():<br>    acc = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(test_lables.shape[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">if</span> np.argmax(predictions[i])==test_lables[i]:<br>            acc += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;accurcy:%f&#x27;</span>%(acc/test_lables.shape[<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><p>最终，测试集准确率约90%。事实上这是个很一般的成绩，也有很多可以优化的地方。</p><p>这篇文章旨在给新手同学一些关于深度神经网络的指引，有兴趣的同学可以优化模型。</p><p>如果感觉到困难，也不用慌，我们将会在每个算法的实战篇中详细介绍，不断加深大家对<strong>深度</strong>强化学习的理解。</p><p>接下来，我们将会回到DQN。</p><h2 id="DQN"><a href="#DQN" class="headerlink" title="DQN"></a>DQN</h2><p>上面，我们了解了深层神经网络到底是啥一回事。现在我们把深层神经网络这套工具，用到强化学习中。</p><p>我们回想一下我们Qleaning，我们需要解决连续状态的问题。那么我们能否用神经网络解决呢？这个就是DQN的思路。</p><h3 id="Deep-network-Qlearning-DQN"><a href="#Deep-network-Qlearning-DQN" class="headerlink" title="Deep network + Qlearning = DQN"></a>Deep network + Qlearning = DQN</h3><p>我们先回归一下Qlearning。</p><p>在Qlearning中，我们有一个Qtable，记录着在每一个状态下，各个动作的Q值。</p><p>Qtable的作用是当我们输入状态S，我们通过<strong>查表</strong>返回能够获得最大Q值的动作A。也就是我们需要找一个S-A的对应关系。</p><p>这种方式很适合格子游戏。因为格子游戏中的每一个格子就是一个状态，但在现实生活中，很多状态并不是<strong>离散</strong>而是<strong>连续</strong>的。而且当</p><p>例如在GYM中经典的CartPole游戏，杆子的角度是<strong>连续</strong>而不是<strong>离散</strong>的。在Atari游戏中，状态也是连续的。</p><p>遇到这些情况，Qtable就没有办法解决。</p><p>我们刚才说了Qtable的作用就是找一个S-A的对应关系。所以我们就可以用一个函数F表示，我们有F(S) = A。这样我们就可以不用查表了，而且还有个好处，函数允许<strong>连续</strong>状态的表示。</p><p>这时候，我们深度神经网络就可以派上用场了。因为我们之前说过，神经网络就可以看成一个万能的函数。</p><p>这个万能函数接受输入一个状态S，它能告诉我，每个动作的Q值是怎样的。</p><p>为了大家能更好理解神经网络的作用，我们可以从另外一个角度理解。 把Qtable三维可视化，就会得到这样一个图。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlup26uhoj61400o4taa02.jpg"></p><p>图中每根柱子的高度，表示状态S下，选择动作A的Q值。</p><p>现在我们用函数来表示，<strong>相当于我们要扭曲一条曲线，这条曲线穿过了离散状态下的所有点。</strong></p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvluqrxwayj60m40eigm802.jpg"></p><p>我们从二维的角度再看一下：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlur7tjiaj60j90beglw02.jpg"></p><p><em>当然，在深度强化学习中，有很多数据的纬度相当高的。这里只是提供一个思考的角度。让大家能够可视化地理解DQN的思路。</em></p><p>现在我们就很清楚了，其实Qlearning和DQN并没有根本的区别。只是DQN用神经网络，也就是一个函数替代了原来Qtable而已。</p><h3 id="神经网络的目标"><a href="#神经网络的目标" class="headerlink" title="神经网络的目标"></a>神经网络的目标</h3><p>我们之前也说过，神经网络需要解决一个问题，就是更新目标怎么设置。</p><p>在手写数字识别等有监督学习的数据集中，有标签好的数据，也就是我们的目标是很明确的。那么在DQN中，我们的目标是什么呢？</p><p>答案其实就在Qlearning一样。 还记得吗？在Qlearning，我们用<strong>下一状态St+1的最大Q值替代St+1的V值</strong>。<strong>V(St+1)加上状态转移产生的奖励R</strong>。就是Q(S,a)的更新目标。</p><p>我们来看下图：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlut9iwnaj60mc09yq3702.jpg"></p><p>假设我们需要更新当前状态St下的某动作A的Q值：Q(S,A),我们可以这样做： 1. 执行A，往前一步，到达St+1; 2. 把St+1输入Q网络，计算St+1下所有动作的Q值； 3. 获得最大的Q值加上奖励R作为更新目标； 4. 计算损失：Q(S,A)相当于有监督学习中的logits； maxQ(St+1) + R 相当于有监督学习中的lables ； 用mse函数，得出两者的loss 5. 用loss更新Q网络。</p><p>也就是，我们用Q网络估算出来的两个相邻状态的Q值，他们之间的距离，就是一个r的距离。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvluv9p3xlj60l602wglm02.jpg"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>其实DQN就是Qlearning扔掉Qtable，换上深度神经网络。</li><li>我们知道，解决连续型问题，如果表格不能表示，就用函数，而最好的函数就是深度神经网络。</li><li>和有监督学习不同，深度强化学习中，我们需要自己找更新目标。通常在马尔可夫链体系下，两个相邻状态状态差一个奖励r经常能被利用。</li></ol><p>DQN其实没有什么神秘的，不是吗？</p><h2 id="DQN代码实战"><a href="#DQN代码实战" class="headerlink" title="DQN代码实战"></a>DQN代码实战</h2><p>于是我们可以用Qlearning算法修改一下，变成DQN的算法。</p><p>其实和Qlearning很像，我们只修改一下。 </p><ol><li>初始化一个网络，用于计算Q值。（在Qlearning，我们用Qtable） </li><li>我们开始一场游戏。 </li><li>随机从一个状态s开始。 </li><li>我们把s输入到Q，计算s状态下，a的Q值 Q（s） </li><li>我们选择能得到最大Q值的动作，a </li><li>我们把a输入到环境，获得新状态s’,r,done </li><li>计算目标 y = r + gamma * maxQ(s’) 8、训练Q网络，缩小Q（s，a）和y 的大小 </li><li>开始新一步，不断更新</li></ol><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvlvb3zu86j60mc09yq3702.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Deep Q-Network Q(a, s)</span><br><span class="hljs-string">-----------------------</span><br><span class="hljs-string">TD Learning, Off-Policy, e-Greedy Exploration (GLIE).</span><br><span class="hljs-string">Q(S, A) &lt;- Q(S, A) + alpha * (R + lambda * Q(newS, newA) - Q(S, A))</span><br><span class="hljs-string">delta_w = R + lambda * Q(newS, newA)</span><br><span class="hljs-string">See David Silver RL Tutorial Lecture 5 - Q-Learning for more details.</span><br><span class="hljs-string">Reference</span><br><span class="hljs-string">----------</span><br><span class="hljs-string">original paper: https://storage.googleapis.com/deepmind-media/dqn/DQNNaturePaper.pdf</span><br><span class="hljs-string">EN: https://medium.com/emergent-future/simple-reinforcement-learning-with-tensorflow-part-0-q-learning-with-tables-and-neural-networks-d195264329d0#.5m3361vlw</span><br><span class="hljs-string">CN: https://zhuanlan.zhihu.com/p/25710327</span><br><span class="hljs-string">Note: Policy Network has been proved to be better than Q-Learning, see tutorial_atari_pong.py</span><br><span class="hljs-string">Environment</span><br><span class="hljs-string">-----------</span><br><span class="hljs-string"># The FrozenLake v0 environment</span><br><span class="hljs-string">https://gym.openai.com/envs/FrozenLake-v0</span><br><span class="hljs-string">The agent controls the movement of a character in a grid world. Some tiles of</span><br><span class="hljs-string">the grid are walkable, and others lead to the agent falling into the water.</span><br><span class="hljs-string">Additionally, the movement direction of the agent is uncertain and only partially</span><br><span class="hljs-string">depends on the chosen direction. The agent is rewarded for finding a walkable</span><br><span class="hljs-string">path to a goal tile.</span><br><span class="hljs-string">SFFF       (S: starting point, safe)</span><br><span class="hljs-string">FHFH       (F: frozen surface, safe)</span><br><span class="hljs-string">FFFH       (H: hole, fall to your doom)</span><br><span class="hljs-string">HFFG       (G: goal, where the frisbee is located)</span><br><span class="hljs-string">The episode ends when you reach the goal or fall in a hole. You receive a reward</span><br><span class="hljs-string">of 1 if you reach the goal, and zero otherwise.</span><br><span class="hljs-string">Prerequisites</span><br><span class="hljs-string">--------------</span><br><span class="hljs-string">tensorflow&gt;=2.0.0a0</span><br><span class="hljs-string">tensorlayer&gt;=2.0.0</span><br><span class="hljs-string">To run</span><br><span class="hljs-string">-------</span><br><span class="hljs-string">python tutorial_DQN.py --train/test</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> argparse<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> gym<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> tensorlayer <span class="hljs-keyword">as</span> tl<br><br><span class="hljs-comment"># add arguments in command  --train/test</span><br><span class="hljs-comment"># 关于argparase的应用，可以看看我这篇知乎专栏：</span><br><span class="hljs-comment"># 小段文讲清argparse模块基本用法[小番外]</span><br><span class="hljs-comment"># https://zhuanlan.zhihu.com/p/111010774</span><br><span class="hljs-comment"># 注意：原代码默认为test，我改为了train。</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;Train or test neural net motor controller.&#x27;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;--train&#x27;</span>, dest=<span class="hljs-string">&#x27;train&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>, default=<span class="hljs-literal">True</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;--test&#x27;</span>, dest=<span class="hljs-string">&#x27;test&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>, default=<span class="hljs-literal">False</span>)<br>args = parser.parse_args()<br><br>tl.logging.set_verbosity(tl.logging.DEBUG)<br><br><span class="hljs-comment">#####################  hyper parameters  ####################</span><br>lambd = <span class="hljs-number">.99</span>  <span class="hljs-comment"># 折扣率(decay factor)</span><br>e = <span class="hljs-number">0.1</span>  <span class="hljs-comment"># epsilon-greedy算法参数，越大随机性越大，越倾向于探索行为。</span><br>num_episodes = <span class="hljs-number">10000</span>  <span class="hljs-comment"># 迭代次数</span><br>render = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 是否渲染游戏</span><br>running_reward = <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment">##################### DQN ##########################</span><br><br><span class="hljs-comment">## 把分类的数字表示，变成onehot表示。</span><br><span class="hljs-comment"># 例如有4类，那么第三类变为：[0,0,1,0]的表示。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_one_hot</span>(<span class="hljs-params">i, n_classes=<span class="hljs-literal">None</span></span>):<br>    a = np.zeros(n_classes, <span class="hljs-string">&#x27;uint8&#x27;</span>)  <span class="hljs-comment"># 这里先按照分类数量构建一个全0向量</span><br>    a[i] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 然后点亮需要onehot的位数。</span><br>    <span class="hljs-keyword">return</span> a<br><br><br><span class="hljs-comment">## Define Q-network q(a,s) that ouput the rewards of 4 actions by given state, i.e. Action-Value Function.</span><br><span class="hljs-comment"># encoding for state: 4x4 grid can be represented by one-hot vector with 16 integers.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model</span>(<span class="hljs-params">inputs_shape</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    定义Q网络模型：</span><br><span class="hljs-string">    1. 注意输入的shape和输出的shape</span><br><span class="hljs-string">    2. W_init和b_init是模型在初始化的时候，控制初始化参数的随机。该代码中用正态分布，均值0，方差0.01的方式初始化参数。</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    ni = tl.layers.Input(inputs_shape, name=<span class="hljs-string">&#x27;observation&#x27;</span>)<br>    nn = tl.layers.Dense(<span class="hljs-number">4</span>, act=<span class="hljs-literal">None</span>, W_init=tf.random_uniform_initializer(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>), b_init=<span class="hljs-literal">None</span>, name=<span class="hljs-string">&#x27;q_a_s&#x27;</span>)(ni)<br>    <span class="hljs-keyword">return</span> tl.models.Model(inputs=ni, outputs=nn, name=<span class="hljs-string">&quot;Q-Network&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_ckpt</span>(<span class="hljs-params">model</span>):  <span class="hljs-comment"># save trained weights</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    保存参数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    tl.files.save_npz(model.trainable_weights, name=<span class="hljs-string">&#x27;dqn_model.npz&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_ckpt</span>(<span class="hljs-params">model</span>):  <span class="hljs-comment"># load trained weights</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    加载参数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    tl.files.load_and_assign_npz(name=<span class="hljs-string">&#x27;dqn_model.npz&#x27;</span>, network=model)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    qnetwork = get_model([<span class="hljs-literal">None</span>, <span class="hljs-number">16</span>])  <span class="hljs-comment"># 定义inputshape[None,16]。16是state数量</span><br>    qnetwork.train()  <span class="hljs-comment"># 调用tensorlayer的时候，需要标注这个模型是否可以训练。(再次吐槽tenorlayers...)</span><br>    train_weights = qnetwork.trainable_weights  <span class="hljs-comment"># 模型的参数</span><br><br>    optimizer = tf.optimizers.SGD(learning_rate=<span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 定义优化器</span><br>    env = gym.make(<span class="hljs-string">&#x27;FrozenLake-v0&#x27;</span>)  <span class="hljs-comment"># 定义环境</span><br><br>    <span class="hljs-comment"># ======开始训练=======</span><br>    <span class="hljs-keyword">if</span> args.train:<br>        t0 = time.time()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_episodes):<br>            <span class="hljs-comment">## 重置环境初始状态</span><br>            s = env.reset()<br>            rAll = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">99</span>):  <span class="hljs-comment"># 最多探索99步。因为环境状态比较少，99步一般也够探索到最终状态了。</span><br>                <span class="hljs-keyword">if</span> render: env.render()<br><br>                <span class="hljs-comment">## 把state放入network，计算Q值。</span><br>                <span class="hljs-comment">## 注意，这里先把state进行onehote处理，这里注意解释下什么是onehot</span><br>                <span class="hljs-comment">## 输出，这个状态下，所有动作的Q值，也就是说，是一个[None,4]大小的矩阵</span><br>                allQ = qnetwork(np.asarray([to_one_hot(s, <span class="hljs-number">16</span>)], dtype=np.float32)).numpy()<br><br>                <span class="hljs-comment"># 在矩阵中找最大的Q值的动作</span><br>                a = np.argmax(allQ, <span class="hljs-number">1</span>)<br><br>                <span class="hljs-comment"># e-Greedy：如果小于epsilon，就智能体随机探索。否则，就用最大Q值的动作。</span><br>                <span class="hljs-keyword">if</span> np.random.rand(<span class="hljs-number">1</span>) &lt; e:<br>                    a[<span class="hljs-number">0</span>] = env.action_space.sample()<br><br>                <span class="hljs-comment"># 输入到环境，获得下一步的state，reward，done</span><br>                s1, r, d, _ = env.step(a[<span class="hljs-number">0</span>])<br><br>                <span class="hljs-comment"># 把new-state 放入，预测下一个state的**所有动作**的Q值。</span><br>                Q1 = qnetwork(np.asarray([to_one_hot(s1, <span class="hljs-number">16</span>)], dtype=np.float32)).numpy()<br><br>                <span class="hljs-comment">##=======计算target=======</span><br>                <span class="hljs-comment">## 构建更新target：</span><br>                <span class="hljs-comment">#    Q&#x27;(s,a) &lt;- Q(s,a) + alpha(r + lambd * maxQ(s&#x27;,a&#x27;) - Q(s, a))</span><br>                maxQ1 = np.<span class="hljs-built_in">max</span>(Q1)  <span class="hljs-comment"># 下一个状态中最大Q值.</span><br>                targetQ = allQ  <span class="hljs-comment"># 用allQ(现在状态的Q值)构建更新的target。因为只有被选择那个动作才会被更新到。</span><br>                targetQ[<span class="hljs-number">0</span>, a[<span class="hljs-number">0</span>]] = r + lambd * maxQ1<br><br>                <span class="hljs-comment">## 利用自动求导 进行更新。</span><br>                <span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<br>                    _qvalues = qnetwork(np.asarray([to_one_hot(s, <span class="hljs-number">16</span>)], dtype=np.float32))  <span class="hljs-comment"># 把s放入到Q网络，计算_qvalues。</span><br>                    <span class="hljs-comment"># _qvalues和targetQ的差距就是loss。这里衡量的尺子是mse</span><br>                    _loss = tl.cost.mean_squared_error(targetQ, _qvalues, is_mean=<span class="hljs-literal">False</span>)<br>                    <span class="hljs-comment"># 同梯度带求导对网络参数求导</span><br>                grad = tape.gradient(_loss, train_weights)<br>                <span class="hljs-comment"># 应用梯度到网络参数求导</span><br>                optimizer.apply_gradients(<span class="hljs-built_in">zip</span>(grad, train_weights))<br><br>                <span class="hljs-comment"># 累计reward，并且把s更新为newstate</span><br>                rAll += r<br>                s = s1<br><br>                <span class="hljs-comment"># 更新epsilon，让epsilon随着迭代次数增加而减少。</span><br>                <span class="hljs-comment"># 目的就是智能体越来越少进行“探索”</span><br>                <span class="hljs-keyword">if</span> d == <span class="hljs-literal">True</span>:<br>                    e = <span class="hljs-number">1.</span> / ((i / <span class="hljs-number">50</span>) + <span class="hljs-number">10</span>)<br>                    <span class="hljs-keyword">break</span><br><br>            <span class="hljs-comment">## 这里的running_reward用于记载每一次更新的总和。为了能够更加看清变化，所以大部分是前面的。只有一部分是后面的。</span><br>            running_reward = rAll <span class="hljs-keyword">if</span> running_reward <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> running_reward * <span class="hljs-number">0.99</span> + rAll * <span class="hljs-number">0.01</span><br>            <span class="hljs-comment"># print(&quot;Episode [%d/%d] sum reward: %f running reward: %f took: %.5fs &quot; % \</span><br>            <span class="hljs-comment">#     (i, num_episodes, rAll, running_reward, time.time() - episode_time))</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Episode: &#123;&#125;/&#123;&#125;  | Episode Reward: &#123;:.4f&#125; | Running Average Reward: &#123;:.4f&#125;  | Running Time: &#123;:.4f&#125;&#x27;</span> \<br>                  .<span class="hljs-built_in">format</span>(i, num_episodes, rAll, running_reward, time.time() - t0))<br>        save_ckpt(qnetwork)  <span class="hljs-comment"># save model</span><br><br>    <span class="hljs-comment">##============这部分是正式游戏了========</span><br>    <span class="hljs-comment"># 这部分就不讲解了，和训练一样。只是少了epsilon-greedy。</span><br>    <span class="hljs-keyword">if</span> args.test:<br>        t0 = time.time()<br>        load_ckpt(qnetwork)  <span class="hljs-comment"># load model</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_episodes):<br>            <span class="hljs-comment">## Reset environment and get first new observation</span><br>            episode_time = time.time()<br>            s = env.reset()  <span class="hljs-comment"># observation is state, integer 0 ~ 15</span><br>            rAll = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">99</span>):  <span class="hljs-comment"># step index, maximum step is 99</span><br>                <span class="hljs-keyword">if</span> render: env.render()<br><br>                <span class="hljs-comment">## Choose an action by greedily (with e chance of random action) from the Q-network</span><br>                allQ = qnetwork(np.asarray([to_one_hot(s, <span class="hljs-number">16</span>)], dtype=np.float32)).numpy()<br>                a = np.argmax(allQ, <span class="hljs-number">1</span>)  <span class="hljs-comment"># no epsilon, only greedy for testing</span><br><br>                <span class="hljs-comment">## Get new state and reward from environment</span><br>                s1, r, d, _ = env.step(a[<span class="hljs-number">0</span>])<br>                rAll += r<br>                s = s1<br>                <span class="hljs-comment">## Reduce chance of random action if an episode is done.</span><br>                <span class="hljs-keyword">if</span> d == <span class="hljs-literal">True</span>:<br>                    <span class="hljs-comment"># e = 1. / ((i / 50) + 10)  # reduce e, GLIE: Greey in the limit with infinite Exploration</span><br>                    <span class="hljs-keyword">break</span><br><br><br>            <span class="hljs-comment">## Note that, the rewards here with random action</span><br>            running_reward = rAll <span class="hljs-keyword">if</span> running_reward <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> running_reward * <span class="hljs-number">0.99</span> + rAll * <span class="hljs-number">0.01</span><br>            <span class="hljs-comment"># print(&quot;Episode [%d/%d] sum reward: %f running reward: %f took: %.5fs &quot; % \</span><br>            <span class="hljs-comment">#     (i, num_episodes, rAll, running_reward, time.time() - episode_time))</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Episode: &#123;&#125;/&#123;&#125;  | Episode Reward: &#123;:.4f&#125; | Running Average Reward: &#123;:.4f&#125;  | Running Time: &#123;:.4f&#125;&#x27;</span>\<br>            .<span class="hljs-built_in">format</span>(i, num_episodes, rAll, running_reward,  time.time()-t0 ))<br></code></pre></td></tr></table></figure><h3 id="Epsilon-greedy"><a href="#Epsilon-greedy" class="headerlink" title="Epsilon-greedy"></a>Epsilon-greedy</h3><p>我们先来说一个在示例代码中的实做技巧。</p><p>还记得我们之前在Qlearning使用了noisy-greedy的方式，保持探索和开发之间的平衡么？</p><p>智能体会根据Q值表选择Q值最大的动作。但在选择动作之前，会先给Q值加上一个随机的噪音，使得最终的最大值带有一定的随机性；随着游戏进行，噪音会逐渐减少，最终噪音将会小得不再影响智能体的决定。</p><p>在DQN，你同样可以使用增加噪音的方式，不过，在示例代码中，我们用另外一种方式取进行。这就是更常用的Epsilon-greedy。其目的是相同的，就是为了保证大部分的state都能被探索到的基础上，最终也能够按照智能体学习到的方式取进行。</p><p>请大家先留一下示例代码中：e = 0.1，这里的e就代表Epsilon，可以理解为一个门槛。</p><p>在选择动作的时候，会先随机一个[0,1]之间的值： 如果随机出来的值，高于这个门槛，智能体将会按照原来的<strong>贪婪算法</strong>，直接选择最大的Q值的动作。这就是开发性的动作。 </p><p>如果随机出来的值，低于这个门槛，智能体将会忽略掉Q值，而直接随机一个动作。这就是<strong>探索性的动作</strong>。 </p><p>Epsilon-greedy用大白话说就是：如果随机出来的值大于Epsilon这个门槛，我们就用greedy算法吧！</p><p>我们看示例代码中，每一次迭代（每一次游戏）进行会调整一次e。</p><p>e = 1. / ((i / 50) + 10) </p><p>随着i越来越大，e将会越来越小。也就是说，门槛会随着迭代次数，越来越小，我们执行greedy算法的机会将会越来越多。让智能体逐渐从<strong>探索</strong>变为<strong>开发</strong>。</p><h3 id="具体算法的解释："><a href="#具体算法的解释：" class="headerlink" title="具体算法的解释："></a>具体算法的解释：</h3><p>Qlearning的更新流程一样。其实，如果你已经明白了深度神经网络和Qlearning，那么代码看起来是很简单了。</p><p>1、我们先建立一个</p><h3 id="建立网络"><a href="#建立网络" class="headerlink" title="建立网络"></a>建立网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model</span>(<span class="hljs-params">inputs_shape</span>):<br>    ni = tl.layers.Input(inputs_shape, name=<span class="hljs-string">&#x27;observation&#x27;</span>)<br>    nn = tl.layers.Dense(<span class="hljs-number">4</span>, act=<span class="hljs-literal">None</span>, W_init=tf.random_uniform_initializer(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>), b_init=<span class="hljs-literal">None</span>, name=<span class="hljs-string">&#x27;q_a_s&#x27;</span>)(ni)<br>    <span class="hljs-keyword">return</span> tl.models.Model(inputs=ni, outputs=nn, name=<span class="hljs-string">&quot;Q-Network&quot;</span>)<br></code></pre></td></tr></table></figure><p><em>示例代码用上了tensorlayer，一般来说用tensorflow的也很方便。这里必须吐槽一下，tensorlayer和tensorflow，同样的层，同样功能的参数，名字居然不一样！还有keras里面的layer。各种坑。 但我们后面的代码都用上了tensorlayer，so。。。</em></p><p>输入层：示例代码中用ni表示。inputs_shape，就是输入矩阵的形状。在强化学习中，我们需要把状态输入到网络中，所以inputs_shape就是状态的形状了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">qnetwork = get_model([<span class="hljs-literal">None</span>, <span class="hljs-number">16</span>])<br></code></pre></td></tr></table></figure><p>后面我们调用的时候，输入的是[None, 16]。注意，前面是状态的数量，也就是说，会输入一个batch大小的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn = tl.layers.Dense(<span class="hljs-number">4</span>, act=<span class="hljs-literal">None</span>, W_init=tf.random_uniform_initializer(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>), b_init=<span class="hljs-literal">None</span>, name=<span class="hljs-string">&#x27;q_a_s&#x27;</span>)(ni)<br></code></pre></td></tr></table></figure><p>和之前Fasion MNIST一样，我们用Dense作为输出。这里没有加一个Dense层，主要是因为这里的状态空间只有16个，这样的模型拟合能力已经足够。</p><p>在更新的时候，有两个地方我们要注意。</p><p><strong>一、 热独编码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">allQ = qnetwork(np.asarray([to_one_hot(s, <span class="hljs-number">16</span>)], dtype=np.float32)).numpy()<br></code></pre></td></tr></table></figure><p>一、这里我们用了to_one_hot函数，把原来的编码，变成<strong>热独编码</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">to_one_hot</span>(<span class="hljs-params">i, n_classes=<span class="hljs-literal">None</span></span>):<br>    a = np.zeros(n_classes, <span class="hljs-string">&#x27;uint8&#x27;</span>)<br>    a[i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure><p>那什么是热独编码呢？</p><p>现在我们有16个不同的state，如果按照一般的分类，可能会把这16个state变成，1,2,3,…,15,16 类。</p><p>在机器学习里面，0,1,2,3..这些数字其实是包含了一个大小的关系的，但我们在分类问题里面，其实每一类都是平等的，并没有大小关系。因此，我们需要把他变成热独编码(One hot)的形式。</p><p>热独编码这个名字其实很形象,就是<strong>只有一点是热的</strong>。</p><p>我们构造一个矩阵，只有该分类的标志位为1，其他全部为0.矩阵的大小，就是类别的个数。所以热独热独，热就是1表示的位置。</p><p>例如 类别1：[1 0 0 0 0 0 0 0 0….0] 类别2：[0 1 0 0 0 0 0 0 0….0] 类别16：[0 0 0 0 0 0 0 0 0….1]</p><p>回到我们示例代码的to_one_hot函数就很好理解了： 我们先构造一个全零的矩阵，大小是[1,n_classes] (n_classes类别个数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.zeros(n_classes, <span class="hljs-string">&#x27;uint8&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后在对应的标志位上，把0变成1，并返回。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">a[i] = 1<br></code></pre></td></tr></table></figure><p><strong>二、数据的形状和格式</strong></p><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.asarray([to_one_hot(s, <span class="hljs-number">16</span>)], dtype=np.float32)<br></code></pre></td></tr></table></figure><p>我们之前说过，神经网络其实可以看做是一个数据的工厂，而在实际写代码的过程中，这个数据工厂有时候并不那么透明，或者并不那么可读。可以说，数据工厂就像一个黑盒子一样，在debug中出来问题，还是比较棘手的。</p><p>所以我们要在输入之前，保证这个工厂的数据是标准的。最好做到以下3点：</p><ol><li>神经网络输入的形状需要和input_shape对应;</li><li>输入格式必须是一个array;</li><li>数据的格式，最好都变成float32的形式。</li></ol><p>在输入之前能先处理好这3点，能够减少很多不必要的麻烦。</p><p>输出：**.numpy()**</p><p>我们数据在输入神经网络这个工厂之后，将会变成另外一种格式：tensor（张量）。最终产生的数据格式也是tensor。</p><p>tensor可以理解为工厂专用的array吧。但有时候，numpy对array的操作并不能直接用到tensor上。所以，在后面加上 .numpy(),把tensor转为array的。</p><p><strong>三、【敲黑板】构造更新目标</strong></p><p>我把关键代码提出来大家看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">DQN:<br>allQ = qnetwork(np.asarray([to_one_hot(s, <span class="hljs-number">16</span>)], dtype=np.float32)).numpy()<br>a = np.argmax(allQ, <span class="hljs-number">1</span>)<br>...<br>Q1 = qnetwork(np.asarray([to_one_hot(s1, <span class="hljs-number">16</span>)], dtype=np.float32)).numpy()<br>maxQ1 = np.<span class="hljs-built_in">max</span>(Q1)  <br>targetQ = allQ<br>targetQ[<span class="hljs-number">0</span>, a[<span class="hljs-number">0</span>]] = r + lambd * maxQ1<br></code></pre></td></tr></table></figure><p>我们举个例子： 假设我们需要更新s状态的Q值(allQ),allQ是所有动作的Q值[0.1 0.2 0.1 0.6]。 如果我们用贪婪算法，我们会选出的动作是【下】，因为【下】的Q值最大。但很遗憾，由于我们采用epsilon-greedy，这次我们随机并随机到a是动作2【右】</p><p>然后我们求出下一状态s1的Q值(Q1),现在我们有下图：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvm2iqegncj60ps06adg902.jpg"></p><p>其中，绿色格子代表动作a。蓝色格子是Q1的最大值，也就是maxQ1 = np.max(Q1)。 </p><p>现在我们需要构造target，因此我们把allQ先复制给targetQ。然后把r + lambd * maxQ1复制给targetQ中对应a的位置。</p><p>所以，我们现在有allQ向targetQ更新：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvm2j2dtg0j30el02mmx8.jpg"></p><p>我们可视化一下，就可以看到Q网络的调整方向：动作1,3,4将会不变，而将会把动作2的Q值向targetQ的动作2方向靠近。 </p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>DQN = Qlearning + network</p><p>Qlearning需要依赖Qtable，所以没办法处理连续state的问题。而我们说，神经网络可以理解成一个magic函数。这个函数式支持连续型的输入的。</p><p>我们用Qlearning的方法，最终可以把这个神经网络，拟合成一个曲面。而每个state就是曲面的一个截面。我们可以从截面看到每个动作的Q值分布。</p><p>而在更新的过程中，我们的算法仍然是TD（0）算法。</p><p>但实际上，示例代码偷了个了懒，虽然DQN是可以解决连续state的问题。但我们用的环境，依然是离散的。大家可以试着改一下代码，完成CartPole-v0环境。</p><p>如果失败了，也没关系。后面我将会介绍几个DQN的变种，包括DoubleDQN，DuelingDQN， 。在这个过程中我们也会学到Experience replay和Fixed Targets Network的技术，把DQN的技术用到极致。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>DQN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习（五）Q-Learning算法</title>
    <link href="/2021/10/18/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/"/>
    <url>/2021/10/18/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本节内容将会开始讲解Q-Learning算法，通过算法理论和代码实践相结合的方式学习。</p><span id="more"></span><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><p>我们说过如何用TD(0)预估状态价值。</p><p>注：TD(0)即1-TD：一步一回头进行更新。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjpsy5y4vj60qi06ijrq02.jpg"></p><p>图解：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjpu7gltfj60hz08zt9002.jpg"></p><p>但大家可能会说，TD能够用在V值，那能不能用在计算Q值上呢？答案是肯定的。</p><h2 id="TD之于Q值估算"><a href="#TD之于Q值估算" class="headerlink" title="TD之于Q值估算"></a>TD之于Q值估算</h2><p>我们现在用上TD的思路。 我们在St，智能体根据策略Pi，选择动作At，进入S(t+1)状态，并获得奖励R。 如果你之前对V和Q的理解足够深，那么不难理解下面这张图。</p><p>V(St+1)的意义是，在St+1到最终状态获得的奖励期望值。 Q(St,At)的意义是，在Q(St,At)到最终状态获得的奖励期望值。 所以我们可以把V(St+1)看成是下山途中的一个路牌，这个路牌告诉我们下山到底还有多远，然后加上R这一段路，就知道Q(St,At)离山脚有多长的路。</p><h2 id="麻烦来了"><a href="#麻烦来了" class="headerlink" title="麻烦来了"></a>麻烦来了</h2><p>但在实际操作的时候，会有一个问题。 在这里我们要估算两个东西，一个是V值，一个是Q值。</p><p>人们想出的办法就是，用下一个动作的Q值，代替V值。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjqe2egddj60se0b2gm902.jpg"></p><p>因为从状态St+1到动作At+1之间没有奖励反馈，所以我们直接用At+1的Q价值，代替St+1的V价值。 这样不就是可以了吗? </p><p><strong>有问题！有大问题！马尔可夫链并不是链，而是树！！！</strong></p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjqfpzv2cj30u00uwmyt.jpg"></p><p>在St+1下，可能有很多动作At+1。不同动作的Q值自然是不同的。 所以Q(St+1,At+1)并不能等价于V(St+1)。</p><p>嘿嘿，虽然不相等，但不代表不能用其中一个来代表V(St+1)。人们认为有个可能的动作产生的Q值能够一定程度代表V(St+1)。</p><ol><li>在<strong>相同策略</strong>下产生的动作At+1，这就是<strong>SARSA</strong>。</li><li>选择<strong>能够产生最大Q值</strong>的动作At+1，这就是<strong>Q-Learning</strong>。</li></ol><h2 id="SARSA"><a href="#SARSA" class="headerlink" title="SARSA"></a>SARSA</h2><p>为什么SARSA用<strong>相同策略</strong>下产生的动作At+1是合理的。答案很简单，它管用。 其实在强化学习，虽然涉及很多数学，但它并不是严谨科学，它更像是工业，只要实际操作管用就行。</p><p>现在我们回到SARSA：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjqk5oj53j60no082aam02.jpg"></p><p>其实SARSA和我们上一篇说的TD估算V值几乎一模一样，只不过我们挪了一下，从V改成Q了。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjqwd9sc3j60kq03qt8v02.jpg"></p><p>注意，这里的At+1是在<strong>同一策略</strong>产生的。也就是说，St选At的策略和St+1选At+1是同一个策略。<strong>这也是SARSA和Qlearning的唯一区别。</strong></p><h2 id="Qlearning"><a href="#Qlearning" class="headerlink" title="Qlearning"></a>Qlearning</h2><p>Qlearning能够产生最大Q值的动作At+1的Q值作为V(St+1)的替代。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjr1vs93zj60ge0e4dgi02.jpg"></p><p>道理其实也很简单：因为我们需要寻着的是能获得<strong>最多奖励</strong>的动作，Q值就代表我们能够获得今后奖励的期望值。所以我们只会选择Q值最大的，也只有最大Q值能够代表V值。</p><p>所以大家可以对比一下Qleanring和SARSA，两者的差别仅仅在Qlearning中</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvjr6g9ainj30l6043dg2.jpg"></p><p>就出现了鼎鼎大名的Qlearning算法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Qlearning和SARSA是多么鼎鼎大名，但直觉上理解还是很简单的。</p><p>现在我们来总结一下整个思路： </p><ol><li>Qlearning和SARSA都是基于TD(0)的。不过在之前的介绍中，我们用TD(0)估算状态的V值。而Qlearning和SARSA估算的是动作的Q值。</li><li>Qlearning和SARSA的核心原理，是用下一个状态St+1的V值，估算Q值。</li><li>既要估算Q值，又要估算V值会显得比较麻烦。所以我们用下一状态下的某一个动作的Q值，来代表St+1的V值。<ol><li>Qlearning和SARSA唯一的不同，就是用什么动作的Q值替代St+1的V值。 SARSA 选择的是在St同一个策略产生的动作。</li><li>Qlearning 选择的是能够产生最大的Q值的动作。</li></ol></li></ol><h2 id="Qlearning算法流程"><a href="#Qlearning算法流程" class="headerlink" title="Qlearning算法流程"></a>Qlearning算法流程</h2><p>我们现在重新整理下，Qleanring的更新流程。 我们将会在任意的state出发 </p><ol><li><p>我们将会用<strong>noisy-greedy的策略</strong>选定动作A</p></li><li><p>在完成动作后，我们将会进入新状态St+1； </p></li><li><p>检查St+1中所有动作，看看哪个动作的Q值最大；</p></li><li><p>用以下的公式更新当前动作A的Q值；</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkdn7pn81j60ko02c0sq02.jpg"></p></li><li><p>继续从s’出发，进行下一步更新 1-6步我们作为一个EP，进行N个EP的迭代。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkdo6gzm6j60vc0dhdgv02.jpg"></p></li></ol><p>在具体实现的时候，有两个方式需要注意：</p><h3 id="Q-table"><a href="#Q-table" class="headerlink" title="Q-table"></a>Q-table</h3><p>Q-table(Q表格)：Qlearning算法非常适合用表格的方式进行存储和更新。所以一般我们会在开始时候，先创建一个Q-tabel，也就是Q值表。这个表纵坐标是状态，横坐标是在这个状态下的动作。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkds85hnbj60di0cd0te02.jpg"></p><p>我们会初始化这个表的值为0。我们的任务就是，通过算法更新，把各个状态下的动作的Q值，填到上面去。</p><h3 id="noisy-greedy"><a href="#noisy-greedy" class="headerlink" title="noisy-greedy"></a>noisy-greedy</h3><p>我们解说过，在选择动作的时候，理论上每次都会使用当前状态下，Q值最大的动作。这样的选择方式，我们称为“贪婪”(greedy)。</p><p>因为我们只选择Q值最大的动作，所以有一些动作没被更新过没有被选择的过的动作，将更新不到。Q值也永远为0。</p><p>举个例子：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkdxc1zfdj61390u00uo02.jpg"></p><p>假设某次智能体经过路径(途中的红色线路)，根据Qlearning算法更新公式，我们计算得到某动作Q值为3。 </p><p>由于其他动作还没执行过，因此他们保持初始值(一般为0)。按照贪婪算法，下一次智能体来到S的时候，会选择Q值最大的动作，也就是Q=3。于是红色路径再次被执行，Q值被更新。然后再一次，智能体仍然只会选红色线路。 </p><p>但事实上，Q值最大的可能是其他的动作，但其他动作没有Q值，只是因为没有被“探索”出来。事实上我们会<strong>希望智能体在开始的时候更多随机行走去探索，而后面更多按照Q值去走动</strong>。</p><p>在我们的示例代码中，用了一个noisy-greedy的方法：</p><p>在每次选择动作的时候，就给我们要选择的动作叠加一个噪音。所谓噪音，就是在原来的值上增加一个随机值。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkee3nql7j60lr0d4q3c02.jpg"></p><p>图中为某状态下，4个可选动作。 其中蓝色部分代表计算出来的Q值，也就是在Qtable上的值。 橙色部分是噪音，通过随机算法随机出来，每一次都会不同。</p><p>大家可以看到，原来蓝色部分Q值最大的是<strong>动作4</strong>(0.3)。但在加上噪音之后，Q值最大的是<strong>动作2</strong>(0.2+0.5)。所以最终智能体会选择<strong>动作2</strong>。</p><p>所以，我们可以通过噪音来“干扰”智能体的选择，达到让智能体有更多探索的机会。</p><p>【敲黑板！！！】 注意！这些噪音只是在选择的时候，临时加上，每次都随机的。只干扰了当前选择，并不会影响真正的Q值。</p><p>当我们认为智能体对环境的了解已经足够充分，我们就可以慢慢减少噪音的大小。</p><p>在实做中，我们只需要在我们每次游戏后，将会减少产生噪音的方差，这样虽然仍然有干扰，但这种干扰将会逐渐减少。直到相对于真正的Q值没有影响的程度。最终，agent将会按照自己的策略选择动作。</p><p>其实解决随机探索的问题还有好多种方法，也会在后续的文章中介绍给大家。</p><h2 id="Qlearning示例代码分析"><a href="#Qlearning示例代码分析" class="headerlink" title="Qlearning示例代码分析"></a>Qlearning示例代码分析</h2><p>在示例代码中，我们的环境是Gym的FrozenLake-v0。关于Gym和FrozenLake-v0的介绍，有需要的同学可以看一下。</p><h3 id="GYM"><a href="#GYM" class="headerlink" title="GYM"></a>GYM</h3><p>在Qlearning开始前，我们先了解一下GYM。 其实和GYM相关的教程已经很多，这里只说最简单。并且希望让大家了解一遍了解GYM，一边对智能体和环境互动有更深入的了解。</p><p>GYM是openAI出的一个模拟环境。除了简单的环境，还有atari游戏。我们日后会尝试把学到的算法，运用到atari游戏中：<a href="https://gym.openai.com/">https://gym.openai.com/</a></p><p>GYM环境对马尔可夫链的抽象非常高。我们可以从下图看到智能体和环境的互动，结合我们之前说的用法，将会对环境有更深刻的理解。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkm7d8qadj60dc0fxmxo02.jpg"></p><p>其实我们可以理解，环境就是老师，负责出题和打分。智能体就是学生，负责做题。智能体的目标就是在老师的题海战术中不断学习，最终获得最多的分数。</p><p>我们从这个角度来看一下： </p><ol><li>老师首先出题，学生听题。环境初始化一个初始的状态S，智能体把S输入到自己算法。</li><li>学生做题。智能体把S输入之后，经过算法进行一番计算。最终会输出action。</li><li>老师改题。老师对学生做的题进行评价。也就是说对这个action进行评价，评价最终输出奖励。奖励越高，刚刚智能体的输出评价就越高。同时，老师会发下一题，就是下一个状态S。</li></ol><p>虽然老子说：天地不仁以万物为刍狗。 但如果用老师-学生去理解环境和智能体的互动，是不是更简单了呢？</p><p>GYM对环境已经高度抽象，我们只需要执行对应的代码，就能让智能体和环境进行互动。减少了我们很多我们自己写环境的代码。我们以后工作一定会把算法用在新的环境，而新环境一般需要自己写的，这时候，参考GYM的这套框架就可以了。</p><h3 id="GYM的基本用法"><a href="#GYM的基本用法" class="headerlink" title="GYM的基本用法"></a>GYM的基本用法</h3><p>如果大家不会安装GYM环境，可以上网找一下，一般只需要pip一下即可。 gym的用法其实也挺简单的。基本需要用到这几个函数。</p><ol><li><p><strong>导入</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gym<br></code></pre></td></tr></table></figure></li><li><p><strong>创建环境</strong>：env = gym.make(‘环境名’)。 其中环境名可以在这找到，还有相关的说明。一般我们会顺手进行初始化。env = gym.make(‘环境名’).unwrapped</p></li><li><p><strong>获取状态特征数和动作空间</strong> N_S = env.observation_space N_A = env.action_space 还记得我们之前说的吗？状态特征，就是我们能观察到的环境。 例如自动驾驶汽车，交通灯算是一个状态特征，这个特征有不同的值，红灯/绿灯。距离最近的行人是一个特征，例如距离这个行人多远。自动驾驶汽车能观察的环境特征越多，感知能力越强，对抉择就越有帮助。所以不一般来说，工程师都会想不断利用各种算法和硬件，从真实环境提取环境特征。 GYM环境对于初学者方便的地方是，对于每个实验，环境都直接提供了环境特征。不需要我们自己去提取了。 如果是连续的状态空间和动作空间，我们可以获取到边界值 s_low_bound = env.observation_space.low s_high_bound = env.observation_space.high 在这里大家可以理解为，老师出题的格式，和学生答案的格式。</p></li><li><p><strong>初始化环境，并返回一个初始状态</strong>。我们一般这样写。 s = env.reset() 老师出的第一道题！</p></li><li><p>学生开始做题了。这里的f其实就是我们的算法。 现在我们就有了一个初始状态s。 假设有一个函数f（s），输入s，获得可以选择出动作a。我们的目标就是找出一个f，能让我们在这个环境中获取最多的reward。 a = f（s）</p></li><li><p>学生提交答案，老师改卷了。把分返回给学生。并且开始出下一题。 我们选取a后。代入step函数，会根据环境配置，会返回4个值：<strong>进入的下一个状态</strong>，<strong>当前获得的奖励r</strong>。除此之外，还有一个<strong>标志位done，表示是否进入最终状态</strong>。另外还有一个**包含信息的值(info)**，但一般我们用不到。可以先忽略。 s_,r,done,info = env.step(a)</p></li><li><p>我们把s = s_.并把步骤4-6组成一个循环，那么游戏就能自动进行下去了。</p></li><li><p>render。如果有render可以把游戏给渲染出来。</p></li></ol><h2 id="FrozenLake代码实例"><a href="#FrozenLake代码实例" class="headerlink" title="FrozenLake代码实例"></a>FrozenLake代码实例</h2><p>FrozenLake是我们学习Qlearning要用到的环境。我们来熟悉一下。</p><p>我们索性地把环境渲染出来。长这样子。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvknyn5pnqj604k05g74802.jpg"></p><p>S：start，出发点。 G：Goal，终点。 F：可以走的路，但偶尔你会因为滑到，自动往前滑一格。 H：hole：是陷阱。</p><p>FrozenLake-v0是一个4*4的网络格子，每个格子可以是起始块，目标块、冻结块或者危险块。 我们的目标是让agent学习从开始块如何行动到目标块上，而不是移动到危险块上。 agent可以选择向上、向下、向左或者向右移动，同时游戏中还有可能吹来一阵风，将agent吹到任意的方块上。</p><p>我们的任务就是让我们的agent，从起点，走到终点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;Q-Table learning algorithm.</span><br><span class="hljs-string">Non deep learning - TD Learning, Off-Policy, e-Greedy Exploration</span><br><span class="hljs-string">Q(S, A) &lt;- Q(S, A) + alpha * (R + lambda * Q(newS, newA) - Q(S, A))</span><br><span class="hljs-string">See David Silver RL Tutorial Lecture 5 - Q-Learning for more details.</span><br><span class="hljs-string">For Q-Network, see tutorial_frozenlake_q_network.py</span><br><span class="hljs-string">EN: https://medium.com/emergent-future/simple-reinforcement-learning-with-tensorflow-part-0-q-learning-with-tables-and-neural-networks-d195264329d0#.5m3361vlw</span><br><span class="hljs-string">CN: https://zhuanlan.zhihu.com/p/25710327</span><br><span class="hljs-string">tensorflow==2.0.00</span><br><span class="hljs-string">tensorlayer==2.0.0</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> gym<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># FrozenLake-v0是一个4*4的网络格子，每个格子可以是起始块，目标块、冻结块或者危险块。</span><br><span class="hljs-comment"># 我们的目标是让智能体学习如何从开始块如何行动到目标块上，而不是移动到危险块上。</span><br><span class="hljs-comment"># 智能体可以选择向上、向下、向左或者向右移动，同时游戏中还有可能吹来一阵风，将智能体吹到任意的方块上。</span><br>env = gym.make(<span class="hljs-string">&#x27;FrozenLake-v0&#x27;</span>)<br><span class="hljs-comment">#有的是v1版本</span><br><span class="hljs-comment">#env = gym.make(&#x27;FrozenLake-v1&#x27;)</span><br><br><span class="hljs-comment"># 设置是否渲染，展示游戏画面。</span><br>render = <span class="hljs-literal">False</span><br>running_reward = <span class="hljs-literal">None</span><br><br><span class="hljs-comment">##================= Implement Q-Table learning algorithm =====================##</span><br><br><span class="hljs-comment">## 建立Q表格，并初始化为全0数组。形状为：[状态空间，动作空间]</span><br>Q = np.zeros([env.observation_space.n, env.action_space.n])<br><br><span class="hljs-comment">## 设置更新的超参数</span><br><span class="hljs-comment">## Q[s, a] = Q[s, a] + lr * (r + lambd * np.max(Q[s1, :]) - Q[s, a])</span><br>lr = <span class="hljs-number">.85</span>  <span class="hljs-comment"># Qleaning的学习率。alpha, if use value function approximation, we can ignore it</span><br>lambd = <span class="hljs-number">.99</span>  <span class="hljs-comment"># 折扣率 decay factor</span><br>num_episodes = <span class="hljs-number">10000</span>  <span class="hljs-comment"># 迭代次数，也就是开始10000次游戏</span><br>rList = []  <span class="hljs-comment"># 用于记录每次迭代的总奖励，这样我们就可以知道智能体是否有进步了。rewards for each episode</span><br><br><span class="hljs-comment">##=================开始游戏=====================##</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_episodes):<br><br>    <span class="hljs-comment">## 重置环境初始状态</span><br>    episode_time = time.time()  <span class="hljs-comment"># 用于记录运行时间，我们可以通过比较运行时间判断算法效率。</span><br>    s = env.reset()  <span class="hljs-comment"># 重置初始状态。</span><br>    rAll = <span class="hljs-number">0</span>  <span class="hljs-comment"># 用于记录这次游戏的总奖励，这里先初始化为0</span><br><br>    <span class="hljs-comment">## 开始Qlearning算法</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">99</span>):<br>        <span class="hljs-keyword">if</span> render: env.render()  <span class="hljs-comment"># 判断是否渲染环境。</span><br><br>        <span class="hljs-comment">## [敲黑板]</span><br>        <span class="hljs-comment">## 从Q表格中，找到当前状态S最大Q值，并在Q值上加上噪音。</span><br>        <span class="hljs-comment">## 然后找到最大的Q+噪音的动作</span><br>        a = np.argmax(Q[s, :] + np.random.randn(<span class="hljs-number">1</span>, env.action_space.n) * (<span class="hljs-number">1.</span> / (i + <span class="hljs-number">1</span>)))<br><br>        <span class="hljs-comment">## 与环境互动，把动作放到env.step()函数，并返回下一状态S1，奖励，done，info</span><br>        <span class="hljs-comment"># s1:下一个环境的状态                   对象</span><br>        <span class="hljs-comment"># 奖励:上一个动作获得的奖励              浮点</span><br>        <span class="hljs-comment"># done:是否进入for循环，再次重置环境     布尔</span><br>        <span class="hljs-comment"># info:对调试有用的诊断信息             字典</span><br>        s1, r, d, _ = env.step(a)<br><br>        <span class="hljs-comment">## 更新Q表格</span><br>        Q[s, a] = Q[s, a] + lr * (r + lambd * np.<span class="hljs-built_in">max</span>(Q[s1, :]) - Q[s, a])<br><br>        rAll += r  <span class="hljs-comment"># rAll累加当前的收获。</span><br>        s = s1  <span class="hljs-comment"># 把下一状态赋值给s，准备开始下一步。</span><br>        <span class="hljs-keyword">if</span> d == <span class="hljs-literal">True</span>:  <span class="hljs-comment"># 如果已经到达最终状态，就跳出for循环。(开始下一次迭代)</span><br>            <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment">##=================更新结束，打印结果=====================##</span><br>    <span class="hljs-comment"># 每次的总收获都放到rlist。可以通过打印看看算法效率。</span><br>    rList.append(rAll)<br>    <span class="hljs-comment"># 每一次迭代获得的总收获rAll,会以0.01的份额加入到running_reward。(原代码这里rAll用了r，个人认为是rAll更合适)</span><br>    running_reward = rAll <span class="hljs-keyword">if</span> running_reward <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> running_reward * <span class="hljs-number">0.99</span> + rAll * <span class="hljs-number">0.01</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Episode [%d/%d] sum reward: %f running reward: %f took: %.5fs &quot;</span> % \<br>          (i, num_episodes, rAll, running_reward, time.time() - episode_time))<br><br><span class="hljs-comment"># 最后打印Q表格，看看Q表格的样子吧。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Final Q-Table Values:\n %s&quot;</span> % Q)<br></code></pre></td></tr></table></figure><h3 id="建立Qtable"><a href="#建立Qtable" class="headerlink" title="建立Qtable"></a>建立Qtable</h3><p>格子世界的状态空间有限，动作空间有限，因此很适合用Qlearning算法解决。</p><p>我们可以做这样的一个表格，我们称为Q值表，如下图所示：当我们预估到相应的Q值后，就直接填上这个表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Initialize table with all zeros</span><br>Q = np.zeros([env.observation_space.n, env.action_space.n])<br></code></pre></td></tr></table></figure><p>np.zeros() 函数，用于生成一个全0矩阵。生成的形状由输入的参数决定。 示例代码中： env.observation_space.n，表示这个环境中状态的数量。 env.action_space.n，表示动作空间的数量。</p><p>生成出的Q-table我们可视化一下，长这样子：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkon7dybpj60wp0u00vx02.jpg"></p><h3 id="算法主体"><a href="#算法主体" class="headerlink" title="算法主体"></a>算法主体</h3><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkonjxyz2j60vc0dhdgv02.jpg"></p><p>为了能更清晰地看出算法的主体，我把示例代码的一些细枝末节先删掉，算法主体大约就是一下几行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_episodes): <br>    s = env.reset()   <span class="hljs-comment">#重置开始状态。</span><br></code></pre></td></tr></table></figure><p>num_episodes，表示进行游戏的次数。每次游戏开始，我们会用env.reset()函数把智能体设置在任意状态出发，一直走到最终状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">99</span>):  <br>        ....<br>        ....<br>        <span class="hljs-keyword">if</span> d ==<span class="hljs-literal">True</span>: <span class="hljs-comment">#d for done。</span><br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>我们设定进行一次游戏，最多进行99步。<br>这个和环境状态多少有关系，当前环境状态16个，在99步前，一般都能到达最终状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.argmax(Q[s, :] + np.random.randn(<span class="hljs-number">1</span>, env.action_space.n) * (<span class="hljs-number">1.</span> / (i + <span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>我们之前说过noisy-greedy的原理，现在我们怎样用代码实现。就是上面这一行，也是Qlearning的重点。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkopjuygwj60kf04r74v02.jpg"></p><p>这一行代码我们可以切开几个步骤来看一下： </p><ul><li>首先，Q[s, :] 我们看一下table表的s列，就是我们当前的状态对应各个动作的Q值。 </li><li>其次，np.random.randn(1, env.action_space.n) 就是我们制造出来的噪音，我们希望噪音随着迭代的进行，将会越来越小。 因此我们乘以 (1. / (i + 1))。当i越来越大的时候，噪音就越来越小了。 </li><li>最后，我们通过np.argmax()获得最大Q值对应的列号，也就是对应的动作。这里要注意，argmax找出最大值后，并不是返回<strong>最大值</strong>，而是返回<strong>最大值的列号</strong>，也就是<strong>动作</strong>。同学在这里要注意理解，我们需要的是动作A，而不是Q值。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">s1, r, d, _ = env.step(a)<br></code></pre></td></tr></table></figure><p>env.step() 我们把动作传入到环境中，环境会给我们返回4个返回值。 </p><ul><li>new_state: 示例代码用s1表示。这个表示我们执行动作后，新的状态。 </li><li>reward: 示例代码中用r表示，执行动作a后，获得的收获</li><li>done：一个标志位，表示这个是否最终状态。</li><li>_ : 其实是info，但我们一般用不到这个值；因此我们把它先忽略。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Q[s, a] = Q[s, a] + lr  (r + lambd  np.<span class="hljs-built_in">max</span>(Q[s1, :]) - Q[s, a])<br></code></pre></td></tr></table></figure><p>我们用newstate的Q值，更新我们现在状态的Q值。我们对应更新公式，就很容易理解了。 注意比较：这里np.max和之前np.argmax函数的区别在于，np.max是返回最大值。而np.argmax返回时最大的行数或者列数。 </p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkoqmui1dj60ko02c0sq02.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = s1<br><span class="hljs-keyword">if</span> d ==<span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>最后，我们更新Q值的任务已经完成，把游戏进行下去。把下一个状态s1赋值给s，重新开始新一步，和新一步的更新。</p><p>但在开始之前，我们检查一下，下一个状态是否就是终止状态了，如果是，这一次游戏就算是完成，开始一次迭代。</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>训练过程 </p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dns">Episode [<span class="hljs-number">0/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00118</span>s <br>Episode [<span class="hljs-number">1/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00093</span>s <br>Episode [<span class="hljs-number">2/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00011</span>s <br>Episode [<span class="hljs-number">3/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00020</span>s <br>Episode [<span class="hljs-number">4/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00102</span>s <br>Episode [<span class="hljs-number">5/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00049</span>s <br>Episode [<span class="hljs-number">6/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00095</span>s <br>Episode [<span class="hljs-number">7/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00032</span>s <br>Episode [<span class="hljs-number">8/10000</span>] sum reward: <span class="hljs-number">0.000000</span> running reward: <span class="hljs-number">0.000000</span> took: <span class="hljs-number">0</span>.<span class="hljs-number">00011</span>s <br></code></pre></td></tr></table></figure><p>我们把Qtable打印出来。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89Q-Learning%E7%AE%97%E6%B3%95/008i3skNly1gvkoukrf0wj61400lxgry02.jpg"></p><p>我们从结果上再理解一次Qtable。因为这和后面DQN等算法有很大关系，希望大家能能够理解。</p><ul><li>Qtable的每一行代表一个状态。</li><li>在每个状态下，智能体可以做4个动作，每个动作Q值分别对应是1,2,3,4列的数值。</li><li>智能体选择动作的方式是： </li></ul><ol><li>找到代表当前状态S的行数 </li><li>在该行中找出最大的值，也就是最大Q值 </li><li>返回这个Q值的列号，这个列号就是动作</li></ol><h2 id="Qlearning总结"><a href="#Qlearning总结" class="headerlink" title="Qlearning总结"></a>Qlearning总结</h2><p>Qlearning本质上是TD(0)算法，采用网格方式更新Qtable。</p><p>示例代码采noisy-greedy的方法。</p><p>但我们也看到Qlearning算法也有很大的局限性，我们看到，无论现实世界还是游戏世界，很多时候状态都是连续的，像表格这种方式，只能解决状态有限且离散的任务。</p><p>DQN算法应运而生！用深度网络，解决了连续状态的问题。</p><p>最后留给大家一个问题： 我们要从Qlearning改为Sarsa，那么应该怎么改呢？</p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Q-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习（四）时序差分TD法计算V值</title>
    <link href="/2021/10/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86TD%E6%B3%95%E8%AE%A1%E7%AE%97V%E5%80%BC/"/>
    <url>/2021/10/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86TD%E6%B3%95%E8%AE%A1%E7%AE%97V%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>虽然蒙特卡罗算法能够在不知道环境信息的时候，以大量采样的方式来估算逼近真实V值，但这种方法也是有一定的限制……</p><span id="more"></span><p>蒙特卡罗算法的局限体现主要体现在以下两个方面：</p><ol><li>蒙特卡罗算法相对动态规划，会有点不那么准。因为蒙特卡罗每一次的路径都是不一样的。</li><li>如果环境的状态空间非常大，或者最终状态只有非常小的概率达到，那么蒙特卡罗算法将会很难处理。</li></ol><h2 id="时序差分算法"><a href="#时序差分算法" class="headerlink" title="时序差分算法"></a>时序差分算法</h2><p>原文再续，书接上一回。</p><p>话说，孙大圣和来自蒙特卡罗的小蒙，一起解决了第一个问题。而让人想不到的是，还有第二关，而且这关的迷宫更大了。</p><p>没办法，大圣只能按照之前的方法去计算V值。</p><p>但这迷宫实在太大了，小猴子根本找不到出口。终于，疲惫的小猴子实在太累了。走到一半，就回头更新了。</p><p>然而，这怎么瞒得过孙大圣的火眼金睛，大圣正想发怒。小蒙却阻止道：等等，让我想想。</p><p>几分钟后，小蒙惊喜道：大圣爷，想不到呀，这小猴乱打乱撞，却让我发现了新的算法。</p><p>大圣狐疑道：真的？！</p><p>小蒙：真的，我们姑且把这个算法叫做<strong>时序差分算法</strong>吧。</p><p>大圣：那你说来听听，如果没道理，哼，吃老孙一棒。</p><p>小蒙：是的是的</p><p>于是小蒙便把这个时序差分算法说出来，为了方便，以后我们就叫TD算法： </p><ol><li>小猴子每走1步，看一下这个路口的V值，还有获得的奖励r； </li><li>回到原来的路口，把刚刚看到的V值和奖励r进行运算，估算出V值。</li></ol><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86TD%E6%B3%95%E8%AE%A1%E7%AE%97V%E5%80%BC/008i3skNly1gvhf9i302lj609m08bdfw02.png"></p><p>于是小猴子便用这种方式，很快地计算出各个路口的V值。</p><h2 id="TD和MC的比较"><a href="#TD和MC的比较" class="headerlink" title="TD和MC的比较"></a>TD和MC的比较</h2><p>TD算法对蒙特卡罗(MC)算法进行了改进。 </p><ol><li><p>不同：TD算法只需要走N步，就可以开始回溯更新；MC需要走到终点才能回溯更新。</p></li><li><p>相同：小猴需要先走N步，每经过一个状态，把奖励记录下来，然后开始回溯。</p></li><li><p>那么，状态的V值怎么算呢？其实和MC一样，我们就假设N步之后，就到达了<strong>“最终状态”</strong>。</p><ol><li>如果该<strong>“最终状态”</strong>我们之前没有走过，那么这个状态上的记录是空白的，所以这个状态的V值为0。</li><li>如果该<strong>“最终状态”</strong>我们已经走过了，这个状态的V值，就是当前的值。</li></ol><p>然后我们开始回溯。</p></li></ol><h2 id="TD原理的直观理解"><a href="#TD原理的直观理解" class="headerlink" title="TD原理的直观理解"></a>TD原理的直观理解</h2><p>我们可以把TD看成是这样一种情况：</p><p>我们从A状态，经过1步，到B状态。我们什么都不管就当B状态是最终状态了。</p><p>但B状态本身就带有一定的价值，也就是<strong>V值</strong>。其意义就是<strong>从B状态到最终状态的总价值期望</strong>。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86TD%E6%B3%95%E8%AE%A1%E7%AE%97V%E5%80%BC/008i3skNly1gvj8874qbaj609o09iwej02.jpg"></p><p>我们假设B状态的V值是对的，那么，通过回溯计算，我们就能知道A状态的更新目标了。</p><p>这就有点像从山顶想知道要下山的路有多长。 </p><p>MC能直接走一趟，看一下到底有多远。</p><p> TD则轻巧一点，先走一段路看一下，看一下有没有路牌指示到山脚还有多远。如果有，那么就把刚刚走的那段路加上路牌指示到山脚的距离相加即可。</p><p> 但有同学可能会问，在开始的时候，我们根本没有路牌呀，所以也不知道到底到山脚有多远。 没错，这是对的。</p><p>但当我们走很多次的时候，路牌系统就能慢慢建立起来。 例如第一次，只有到了山脚，我才知道山脚前一站离山脚的的真实距离。于是我更新了山脚前一站的路牌。第二次，我在山脚前一站路就能看到路牌，所以我就可以更新山脚前一站的路牌了…一直到山顶，就这样一直建立整座山的路牌系统。</p><p>因此，TD算法是一个“前人栽树，后人乘凉”的算法。</p><h2 id="更新公式"><a href="#更新公式" class="headerlink" title="更新公式"></a>更新公式</h2><p>刚刚我们对TD有个直观的理解：TD并走走完整段路程，而是半路就截断。用半路的路牌，更新当前的路牌。</p><p>所以我们只需要把MC的更新目标，改为TD的更新目标即可。</p><p>在MC，G是更新目标，而在TD，我们只不过把更新目标从G，改成r+gamma*V</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%97%B6%E5%BA%8F%E5%B7%AE%E5%88%86TD%E6%B3%95%E8%AE%A1%E7%AE%97V%E5%80%BC/008i3skNly1gvj8oxww0xj60wc0dmjse02.jpg"></p><h2 id="一些额外理解"><a href="#一些额外理解" class="headerlink" title="一些额外理解"></a>一些额外理解</h2><p>整个MC和TD的学习，让我有一个直观的感觉。跟物理的能量转换有一点相似。在物理中，球从上往下自由落体，是势能转化为动能的过程。随着势能逐渐减少，兑换出来的动能将会越来越多。这是不是有点像V值随着智能体的前进，会慢慢兑现为奖励R值？</p><p>又例如:我们下棋的时候，说的势，其实V。在开局的时候，我们必须必对手有更高的势，在中盘对子，就是兑现自己的V，转换为奖励R值。</p><p><strong>TD更厉害的是，在很多时候，我们并不需要一直走到最后，我们可以先用后面的估算，然后调整当前状态。</strong></p><p>再走一步。 这种想法后来应用到很多算法上ALPHA ZORO中截断蒙特卡罗搜索树，TD-CFR等。如果状态太多，深度太长，我们可以用这种方式先截断，然后想办法把后面的V值通过多次就可以更新。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/110132710">https://zhuanlan.zhihu.com/p/110132710</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时序差分法</tag>
      
      <tag>TD</tag>
      
      <tag>V值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习（三）蒙特卡罗方法求V值</title>
    <link href="/2021/10/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/"/>
    <url>/2021/10/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们知道了求解V值和Q值的方法，但是如果求解所有节点的值，我们每一个节点都用同样的方法，消耗必然会很大。所以人们发明了许多方式去计算Q值和V值。</p><span id="more"></span><p>动态规划虽然能解决问题，但对资源的消耗实在太多。而且，还必须了解整个整个环境的构造，面对一些未知的环境还真不好搞。</p><p>本篇将会介绍如何<strong>用蒙特卡罗算法求状态V值</strong>。</p><h2 id="先看故事"><a href="#先看故事" class="headerlink" title="先看故事"></a>先看故事</h2><p>话说，齐天大圣孙悟空，护送唐三藏到西方取经。路过一神秘洞穴，突然被怪物的法宝葫芦吸了进去。</p><p>葫芦里面原来是另外一个次元的世界，大圣转了两圈，怎么都出不去。气的大圣破口大骂，可是又破坏不了这葫芦。正在踌躇之际，前面来了一个人。</p><p>说道：大圣呀，我是来自西域的蒙特卡罗，我被困在这里很久啦。这个迷宫呀，不但要我们找到出口，而且要我们<strong>找出从任何一个位置离出口最近的路</strong>呀。但大圣请放心，只要大圣助我一臂之力，你如此如此，这般这般便可。我定可以解决这个问题。</p><p>大圣听道，连忙点头称是。</p><p>于是大圣从身上拔下一条汗毛，轻轻一吹，变成了小猴。于是大圣开始吩咐小猴：</p><ol><li>你从这里出去之后，就随便逛，走的时候要记住 <strong>走的路径</strong> 和 <strong>每一步获得的奖励</strong>。</li><li>如果你到了最终出口，那就沿原路往回走，在每个经过的路口，留下一张字条： 字条上写上你获得的奖励 加上 你上一个路口的标记的路口的价值。这个价值你可以乘以一个折扣，嗯，就乘以0.9吧。 </li><li>你就这样一直沿路回来可以了。</li></ol><p>于是小猴一蹦一跳就出去了，过了一会，回来了。</p><p>这时候大圣正在吃香蕉，看到小猴回来，扔了一根香蕉给小猴，说： 你继续出去吧，和上次一样就好啦。</p><p>小猴不解道：那如果遇到我上次见到的路口，我是应该怎么做呢？</p><p>大圣想了一下说：你不用管，你把这一次的数给记下就可以了。大圣又给了小猴一根香蕉。让小猴继续跑。</p><p>小猴就是这样，一直跑一直跑，跑了许多次，蒙特卡罗跟大圣说：大圣爷，我看差不多了，你去让小猴子，把所有的数都给平均一下，就是我们要求的V值了。</p><h2 id="蒙特卡罗算法"><a href="#蒙特卡罗算法" class="headerlink" title="蒙特卡罗算法"></a>蒙特卡罗算法</h2><p>看完上面的故事，应该对蒙特卡罗算法有大概的认识。现在我们来具体看看蒙特卡罗算法。</p><ol><li>我们把智能体放到环境的任意状态；</li><li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li><li>重复步骤2，直到最终状态；</li><li>我们从最终状态开始向前回溯：计算每个状态的G值。</li><li>重复步骤1-4多次，然后平均每个状态的G值，这就是我们需要求的每个状态的V值。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实从直觉上，我们很容易理解。</p><p>我们分成两部分，首先我们要理解每一次我们算的G值的意义。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvh8x5e0m7j61400rigno02.jpg"></p><ul><li>第一步，我们根据策略往前走，一直走到最后，期间我们什么都不用算，但需要记录<strong>每一个状态转移</strong>，我们获得多少<strong>奖励r</strong>即可。</li><li>第二步，我们从终点往前走，一边走一边计算G值。G值等于上一个状态的G值(记作G’),乘以一定的折扣(gamma),再加上奖励r。</li></ul><p>所以<strong>G值</strong>的意义在于，在这一次游戏中，<strong>某个状态到最终状态的奖励总和</strong>(理解时可以忽略折扣值)。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvh91ymu2zj60gi06kaaa02.jpg"></p><p>当我们进行多次试验后，我们有可能会经过某个状态多次，通过回溯，也会有多个G值。 重复我们刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。而V值时候某个状态下，我们通过影分身到达最终状态，所有影分身获得的奖励的平均值。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvh95q43htj61400iqabv02.jpg"></p><p>所以大家看到，其实当我们之前理解清楚V值和Q值的意义，我们理解蒙特卡罗其实很轻松的。</p><h2 id="再进一步"><a href="#再进一步" class="headerlink" title="再进一步"></a>再进一步</h2><p>蒙特卡罗算法单独拿出来，在强化学习中效率还是比较低的。所以会结合其他的方式进行应用。这些我们会在后面具体算法中讲到。</p><p>在这一篇中，希望大家能够理解两点：</p><ol><li><strong>G的意义：在某个路径上，状态S到最终状态的总收获</strong></li><li><strong>V和G的关系：V是G的平均数</strong></li></ol><p>到这里要注意一点：<strong>V和策略是相关的</strong>，那么在这里怎么体现呢？这个非常重要，因为在PPO算法中，离线策略就与这个有关。这里可以稍微先说一下。</p><p>我们仍以上图为例子，以策略A进行游戏。其中有100次经过S点，经过S点后有4条路径到达最终状态，计算G值和每条路径次数分别如下：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvh9e2udk8j60lz0bzjsf02.jpg"></p><p>策略A采用<strong>平均策略</strong>，这时候 V = 5。</p><p>现在我们采用策略B，<strong>由于策略改变，经过某条路径的概率就会产生变化。因此最终试验经过的次数就不一样了。</strong></p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvh9gnm0vkj61400ls40p02.jpg"></p><p>最终计算的 V = 7.55。</p><h2 id="蒙特卡罗的缺陷"><a href="#蒙特卡罗的缺陷" class="headerlink" title="蒙特卡罗的缺陷"></a>蒙特卡罗的缺陷</h2><p>在实际引用中，蒙特卡罗虽然比动态规划消耗要少一点；而且并不需要知道整个环境模型。</p><p>但蒙特卡罗有一个比较大的缺点，就是<strong>每一次游戏，都需要先从头走到尾，再进行回溯更新</strong>。如果最终状态很难达到，那小猴子可能每一次都要转很久很久才能更新一次G值。</p><p>这样计算其实相当麻烦，因为每一个状态都需要建立一个空间，记录每个轨迹下的G值。</p><p>那有没有一种方法，可以用更少的空间计算V值呢？当然有！</p><h2 id="平均香蕉"><a href="#平均香蕉" class="headerlink" title="平均香蕉"></a>平均香蕉</h2><p>有两条长度分别为A，B的香蕉(并假设:A&gt;B)。 如果我要知道他们平均有多长。我只需要把A切成和B长；然后把多出来的那一节，再切一半，接到B就可以了。这时候，我们称那条加长了的B香蕉为平均香蕉。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvhdkmtavaj60du0b9aa802.jpg"></p><p>如果这时候有第三条C呢？其实原理也一样，比较一下C和平均香蕉，然后把差切出来。但这个时候因为我们有3条香蕉要平均，所以我们要分3份，再接到平均香蕉上。再来一根香蕉也一样。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvhdle728jj60ha0bvgly02.jpg"></p><p>明白了吗？</p><p>V是G的平均值，但我们可以用<strong>增量更新</strong>的方式： 现在我们只需要记录之前的平均值V，新加进来的G，和次数N。我们把V和G的差，除以N，然后再加到原来的平均值V上，就能计算到新的V值。<br>$$<br>V_{new}=\frac{G-V_{old}}{N}+V_{old}<br>$$<br>V_old：原来的V值，也就是平均香蕉</p><p>G：这一次回溯后，计算出来的G值，也就是新加进来的香蕉</p><p>N: 这个状态被经过多少次了</p><p> V_new：新计算出来的V值，也就是新的平均香蕉</p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>但其实这样计算还是比较麻烦，我们甚至可以不用记录N，把(1/N)设置成为一个固定的数，例如0.1、0.2(还记得超参数吗？)。我们把这个值称为<strong>学习率</strong>。</p><p>这就相当于，我们新来的香蕉G和平均香蕉V的差的十分之一，会被加到平均香蕉上！也就是说，每一次G都会引导V增加一些或者减少一些，而这个V值慢慢就会接近真正的V值。</p><p>但这数值不就是不对了吗？但为什么可以这样做呢？ 这是因为V值是一个”客观存在”的值，我们可以用任何其他方式去求它。而G值是围绕V值的值，G每次出现会都往自己身边拉一下。 就像很多个G在拔河，有的G比V大，有的比G小，有的G力气大，有的G力气小。但没问题，当有足够多的G在的时候，他们一起拉，V就会接近于那个客观存在的V值。</p><p>图中：我们假设橙色的V是客观存在的那个V值，G值会一次又一次把现在的V值(黄色)往左右拉，当次数足够多的时候。V值就和真实的V值很接近了。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvhe0lw6gfj60h30d13yu02.jpg"></p><p>所以，我们把这里的G，也称为V的<strong>更新目标</strong>。</p><p>而学习率就可以理解为，每次V向目标靠近的幅度；学习率越大，表示向G靠近的幅度越大，反之则越小。但是不是越大越好呢？大家可以仔细想想。</p><p>因此，我们可以用两种角度理解MC的更新公式：</p><p>第一种，我们用“平均香蕉”来理解。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvhe0xwq5ij60im06pdg802.jpg"></p><p>第二种，我们用“G的拔河”来理解。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%96%B9%E6%B3%95%E6%B1%82V%E5%80%BC/008i3skNly1gvhe1ctw6vj60ix07u3yu02.jpg"></p><p>所以大家不用记公式，理解更重要。</p><p>在下一篇，我们将介绍<strong>时序差分(TD)算法</strong>来解决这个问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/109755443">https://zhuanlan.zhihu.com/p/109755443</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>V值</tag>
      
      <tag>蒙特卡罗方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像处理PIL</title>
    <link href="/2021/10/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/"/>
    <url>/2021/10/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/</url>
    
    <content type="html"><![CDATA[<p>PIL库是一个具有强大图像处理能力的第三方库，不仅包含了丰富的像素、色彩操作功能，还可以用于图像归档和批处理。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>PIL库支持图像存储、显示和处理，它能够处理几乎所有图片格式，可以完成对图像的缩放、剪裁、叠加以及向图像添加线条、图像和文字等操作。</p><p>PIL库主要可以实现<strong>图像归档</strong>和<strong>图像处理</strong>两大功能。</p><ol><li>图像归档：对图像进行批处理、生成图像预览、图像格式转换等。</li><li>图像处理：图像基本处理、像素处理、颜色处理等。</li></ol><p>安装PIL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install pillow<br></code></pre></td></tr></table></figure><p>本文重点介绍PIL库中的<code>Image</code>类，<code>ImageFilter</code>类、<code>ImageEnhance</code>类。</p><h2 id="Image类"><a href="#Image类" class="headerlink" title="Image类"></a>Image类</h2><p>导入方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br></code></pre></td></tr></table></figure><p>在PIL中，任何一个图像文件都可以用Image对象表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据参数加载图像文件</span><br><span class="hljs-comment">#图像文件的栅格数据不会被直接加载或解码，程序只是读取了图像文件的头部元数据信息</span><br><span class="hljs-comment">#这部分信息标识了图像的格式、颜色、大小等信息。因此，打开时会很快</span><br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./beauty.jpg&quot;</span>)<br><br><span class="hljs-comment">#展示图像</span><br>img.show()<br><br><span class="hljs-comment">#图像格式:&#x27;JPEG&#x27;</span><br>img.<span class="hljs-built_in">format</span><br><br><span class="hljs-comment">#图像大小:(1024, 1759)</span><br>img.size<br><br><span class="hljs-comment">#图像的色彩模式:&#x27;RGB&#x27;</span><br>img.mode<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/008i3skNly1gvl3uaahn4j60sg1cvwhz02.jpg"></p><p>Image还可以读取序列类图像文件，包括：GIF、FLI、FLC、TIFF等格式文件。<code>open()</code>方法打开一个序列图像时，自动加载序列中的第一帧，使用<code>seek()</code>和<code>tell()</code>可以在不同帧之间移动。</p><p><code>Image.seek()</code>:跳转并返回图像中的指定帧</p><p><code>Image.tell()</code>:返回当前帧的序号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#展示gif图像文件的第一帧</span><br>gif_img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./tuxue.gif&quot;</span>)<br>gif_img.show()<br><br><span class="hljs-keyword">try</span>:<br>    gif_img.save(<span class="hljs-string">f&#x27;picframe<span class="hljs-subst">&#123;gif_img.tell()&#125;</span>.png&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        gif_img.seek(gif_img.tell()+<span class="hljs-number">1</span>)<br>        gif_img.save(<span class="hljs-string">f&#x27;picframe<span class="hljs-subst">&#123;gif_img.tell()&#125;</span>.png&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;共有<span class="hljs-subst">&#123;gif_img.tell()+<span class="hljs-number">1</span>&#125;</span>帧数&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Image.convert(mode)</span><br><span class="hljs-comment">#转换图像的色彩模式</span><br>img.convert(<span class="hljs-string">&quot;RGB&quot;</span>)<br>img.show()<br><br><span class="hljs-comment">#Image.thumbnail(size)</span><br><span class="hljs-comment">#创建图像的缩略图，size是二元元组</span><br>img.thumbnail((<span class="hljs-number">128</span>,<span class="hljs-number">128</span>))<br>img.save(<span class="hljs-string">&quot;img_th.jpg&quot;</span>)<br><br><span class="hljs-comment">#Image.resize(size)按照size调整尺寸，生成副本</span><br>img.show()<br>img.resize((<span class="hljs-number">524</span>,<span class="hljs-number">524</span>))<br><br><span class="hljs-comment">#Image.rotate(angle)逆时针旋转angle度数，生成副本</span><br>img.rotate(<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>Image类可以对每个像素点或一幅RGB图像的每个颜色通道单独操作。</p><p><code>Image.split()</code>:提取RGB图像的每个颜色通道，返回图像副本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./beauty.jpg&quot;</span>)<br>r,g,b = img.split()<br>r.show()<br>g.show()<br>b.show()<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/008i3skNly1gvl3l8t6fkj61qu0u0gre02.jpg"></p><p><code>Image.merge(mode,bands)</code>:合并通道，mode表示色彩模式，bans表示新的色彩通道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">om = Image.merge(<span class="hljs-string">&quot;RGB&quot;</span>,(b,g,r))<br>om.save(<span class="hljs-string">&quot;beauty_bgr.jpg&quot;</span>)<br><br>img_bgr = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./beauty_bgr.jpg&#x27;</span>)<br>img_bgr.show()<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/008i3skNly1gvl3qn6zj9j60sg1cvmzk02.jpg"></p><h2 id="ImageFilter类"><a href="#ImageFilter类" class="headerlink" title="ImageFilter类"></a>ImageFilter类</h2><p>ImageFilter类可以过滤图像文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageFilter<br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./beauty.jpg&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>ImageFilter.BLUR</code>:图像的模糊效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">om = img.<span class="hljs-built_in">filter</span>(ImageFilter.BLUR)<br>om.show()<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/008i3skNly1gvl464d9qwj60n80rsjt402.jpg"></p><p><code>ImageFilter.CONTOUR</code>:图像的轮廓效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">om = img.<span class="hljs-built_in">filter</span>(ImageFilter.CONTOUR)<br>om.show()<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/008i3skNly1gvl43twbmqj60n80rstbf02.jpg"></p><p><code>ImageFilter.DETAIL</code>:图像的细节效果</p><p><code>ImageFilter.EDGE_ENHANCE</code>:图像的边缘加强效果</p><p><code>ImageFilter.EMBOSS</code>:图像的浮雕效果</p><p><code>ImageFilter.FIND_EDGES</code>:图像的边界效果</p><p><code>ImageFilter.SMOOTH</code>:图像的平滑效果</p><p><code>ImageFilter.SHARPEN</code>:图像的锐化效果</p><h2 id="ImageEnhance类"><a href="#ImageEnhance类" class="headerlink" title="ImageEnhance类"></a>ImageEnhance类</h2><p>ImageEnhance类提供了更高级的图像增强功能：调整色彩度、对比度、锐化等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageEnhance<br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./beauty.jpg&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>ImageEnhance.enhance(factor)</code>:对选择属性的数值增强factor倍</p><p><code>ImageEnhance.Color(img)</code>:调整图像img的颜色平衡</p><p><code>ImageEnhance.Contrast(img)</code>:调整图像img的对比度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">om = ImageEnhance.Contrast(img)<br>om.enhance(<span class="hljs-number">20</span>).show()<br></code></pre></td></tr></table></figure><p><img src="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86PIL/008i3skNly1gvl4fid28kj60n80rsn1b02.jpg"></p><p><code>ImageEnhance.Brightness(img)</code>:调整图像img的亮度</p><p><code>ImageEnhance.Sharpness(img)</code>:调整图像img的锐度</p><h2 id="图像的字符串绘制"><a href="#图像的字符串绘制" class="headerlink" title="图像的字符串绘制"></a>图像的字符串绘制</h2><p>位图图片是由不同颜色的像素点组成的规则分布，如果采用字符串代替像素点，图像就成了字符画。</p><h3 id="1-定义字符集"><a href="#1-定义字符集" class="headerlink" title="1. 定义字符集"></a>1. 定义字符集</h3><p>定义一个字符集代替图像的像素点，使得每个字符对应图像中的不同颜色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ascii_char = <span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&#x27;. &quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-灰度转换公式"><a href="#2-灰度转换公式" class="headerlink" title="2. 灰度转换公式"></a>2. 灰度转换公式</h3><p>图像的色彩无法被黑白的ASCII码直接模拟，可以使用灰度值将彩色图像转换为高质量的黑白文稿。</p><p>灰度值是指黑白图像中的颜色深度，白色为255，黑色为0。这里定义灰度值从大到小依次使用字符集中从左到右的符号，转换公式如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">Gray = R * 0.2126 + G * 0.7152 + B * 0.0722<br></code></pre></td></tr></table></figure><p>R、G、B分别是像素点中RGB的值，转换函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_char</span>(<span class="hljs-params">r,b,g,alpha = <span class="hljs-number">256</span></span>):<br>    <span class="hljs-keyword">if</span> alpha == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span><br>    gray = <span class="hljs-built_in">int</span>(r * <span class="hljs-number">0.2126</span> + g * <span class="hljs-number">0.7152</span> + b * <span class="hljs-number">0.0722</span>)<br>    unit = <span class="hljs-number">256</span> / <span class="hljs-built_in">len</span>(ascii_char)<br>    <span class="hljs-keyword">return</span> ascii_char[gray//unit]<br></code></pre></td></tr></table></figure><h3 id="3-转换案例"><a href="#3-转换案例" class="headerlink" title="3. 转换案例"></a>3. 转换案例</h3><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>ascii_char = <span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\&quot;^`&#x27;. &quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_char</span>(<span class="hljs-params">r,b,g,alpha = <span class="hljs-number">256</span></span>):<br>    <span class="hljs-keyword">if</span> alpha == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span><br>    gray = <span class="hljs-built_in">int</span>(r * <span class="hljs-number">0.2126</span> + g * <span class="hljs-number">0.7152</span> + b * <span class="hljs-number">0.0722</span>)<br>    unit = <span class="hljs-number">256</span> / <span class="hljs-built_in">len</span>(ascii_char)<br>    <span class="hljs-keyword">return</span> ascii_char[<span class="hljs-built_in">int</span>(gray//unit)]<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./milk.jpg&quot;</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">    width,height = 100,60</span><br><span class="hljs-string">    img = img.resize((width,height))</span><br><span class="hljs-string">    txt = &quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">    for i in range(height):</span><br><span class="hljs-string">        for j in range(width):</span><br><span class="hljs-string">            txt += get_char(*img.getpixel((j,i)))</span><br><span class="hljs-string">        txt += &quot;</span>\n<span class="hljs-string">&quot;</span><br><span class="hljs-string">    fp = open(&#x27;pic_char.txt&#x27;,&#x27;w&#x27;)</span><br><span class="hljs-string">    fp.write(txt)</span><br><span class="hljs-string">    fp.close()</span><br><span class="hljs-string"></span><br><span class="hljs-string">main()              </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PIL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习（二）V值和Q值</title>
    <link href="/2021/10/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/"/>
    <url>/2021/10/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>本文内容主要介绍V值和Q值，属于强化学习领域，参考图片均保留水印来源，资料均来源于网络，在文末参考链接中已经注明。</p><span id="more"></span><h2 id="赢在将来"><a href="#赢在将来" class="headerlink" title="赢在将来"></a>赢在将来</h2><p>要理解Q值和V值，就需要先理解马尔可夫树，为什么我要把马尔可夫链叫成马尔可夫树呢？我在之前的文章已经说过。如果有需要可以看看。</p><p>马尔可夫告诉我们： 当智能体从一个状态S，选择动作A，会进入另外一个状态S’；同时，也会给智能体奖励R。 奖励既有正，也有负。正代表我们鼓励智能体在这个状态下继续这么做；负得话代表我们并不希望智能体这么做。 在强化学习中，我们会用奖励R作为智能体学习的引导，期望智能体获得尽可能多的奖励。</p><p>但更多的时候，我们并不能单纯通过R来衡量一个动作的好坏。来看下面一个例子：</p><p>假设，10天之后进行期末考试，我们今天有两个选择： 1. 放弃吧，我们玩游戏！我们每天可以获得+1心情值； 2. 决心努力一搏，我们开始学习吧！每天我们-2心情值。</p><p>从这10天看，我们肯定是选择【1.玩游戏】。因为10天后，我们虽然考试没过，但至少收获10天的快乐。</p><p>但事实上，我们再看远一点：因为挂科，接受老师怒吼攻击！心情值马上减5；父母因为我考得好成绩，给了更多的零用钱。心情值加200点。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgb1gke3wj60ph0cgdgi02.jpg"></p><p>所以，假设我们能预知未来，我们一定会选择【2.去复习】</p><p>因此，我们必须用长远的眼光来看待问题。我们要把未来的奖励也计算到当前状态下，再进行决策。</p><h2 id="更复杂的未来"><a href="#更复杂的未来" class="headerlink" title="更复杂的未来"></a>更复杂的未来</h2><p>但在实际情况中，比我们刚才想想要复杂得多。</p><p>我们之前说过，未来是充满不确定性的，不确定性既包含在<strong>我们的策略</strong>，也包含在<strong>环境之中</strong>。</p><p>也就是说，即使我现在努力学习，我也不能100%保证我我一定考得好成绩。即使有好成绩，父母也不一定会给我更多零用钱。但即使挂科了，老师也不一定大发雷霆。</p><p>嗯，好吧。那看上去还是应该及时行乐，选择打游戏！</p><p>嗯，学渣永远是学渣，而你的学霸朋友（如果有的话），会先让你算一下：</p><p>我们把当前状况再理一下：</p><ol><li>10天后考试，玩游戏1天，心情+1；复习1天，心情-2。10天后，玩游戏心情+10，复习心情-20。</li><li>不复习，100%挂科，被老师怒吼：-5点心情 </li><li>复习，10%挂科，同样被老师怒吼：-5点心情；80%不挂科，努力终于有回报：+10点心情；10%不挂科，且得到父母的零用钱 心情暴击+200点。</li></ol><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgb5jb7v7j61400ltq4h02.jpg"></p><p>学霸深情地对学渣说：我知道你对概率和期望不太熟悉，那么我们现在就用影分身大法吧！</p><p>假设，有100个你自己，所有你都在玩游戏，并且所有的你都挂科了。 如果选择不复习。那么100个你一共可以获得多少奖励？</p><p>学渣：这我会！ - 10天都在玩，那么玩游戏心情就+10，100个我就是1000点心情！ - 必定会挂科了-5，100个分身就是-500点。所以最终+500点心情，那么就加500点心情！果然还是打游戏比较划算。</p><p>学霸： 你别兴奋呀，那如果复习呢？ </p><p>学渣： - 10个分身挂科，这些分身复习了，-20心情；复习了还挂科，-5心情；一共-250心情值。 - 80个分身不挂科，这些分身复习了，-20心情；但不挂科，+10，最终还是只有-10点心情，80个我最终-800。 - 还有10个分身不挂科，而且获得父母的零用钱，因为复习-20心情，最终+1800点。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgb96au57j61400b375x02.jpg"></p><p>哇！比去玩的还多！我必须马上学习！</p><p>看完上面的故事，学霸可能会觉得麻烦。那不就是概率求期望么，真的要这么麻烦吗？</p><p>但在实际运用中，大多时候我们并不知道真实概率是多少。以上的概率都是我们自己估算，没有经过验证的。</p><p>在强化学习中，我们<strong>为了获得概率，我们将会不断地让我们智能体重复，或者让多个智能体进行试验以获得数据</strong>。</p><p>当然，100个影分身是很费查克拉的，我们在计算的时候也费时间。<strong>怎么在最少消耗里预估出合理的概率呢</strong>？这些知识我们将会在后面具体算法为大家讲解。</p><h2 id="Q值和V值的意义"><a href="#Q值和V值的意义" class="headerlink" title="Q值和V值的意义"></a>Q值和V值的意义</h2><p>所以我们在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。</p><p>为了方便，我们希望可以有一种方法衡量我做出每种选择价值。这样，我只要看一下标记，以后的事情我也不用理了，我选择那个动作价值更大，就选那个动作就可以了。</p><p>也就是说，我们让复习和游戏都有一个标记，这个标记描述了这个动作的价值：打游戏 +500；复习 +750</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgyrx2xrwj60c50cnt8t02.jpg"></p><p>当然，我们也可以把这个标记标在状态上。为了方便沟通，我们这样定义：</p><ul><li><p>评估<strong>动作</strong>的价值，我们称为<strong>Q值</strong>：它代表了智能体选择这个动作后，一直到最终状态<strong>奖励总和</strong>的<strong>期望</strong>；</p></li><li><p>评估<strong>状态</strong>的价值，我们称为<strong>V值</strong>：它代表了智能体在这个状态下，一直到最终状态的<strong>奖励总和</strong>的<strong>期望</strong>。</p></li></ul><p>价值越高，表示我从<strong>当前状态</strong>到<strong>最终状态</strong>能获得的<strong>平均奖励</strong>将会越高。因为智能体的目标数是获取尽可能多的奖励，<strong>所以智能体在当前状态，只需要选择价值高的动作就可以了</strong>。</p><p>对于Q值和V值的定义非常非常重要。对Q值和V值的清晰理解，是理解强化学习中几乎所有算法的基础。 为此，我们不妨再用“影分身”大法再梳理一遍。</p><h2 id="V值的定义"><a href="#V值的定义" class="headerlink" title="V值的定义"></a>V值的定义</h2><p>上面的定义理解起来好难，我们用“影分身”大法，理解起来就容易多了</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgz4jn4kfj60ke0dpaax02.jpg"></p><p>假设现在需要求某状态S的V值，那么我们可以这样：</p><ol><li>我们从S点出发，并影分身出若干个自己;</li><li>每个分身按照当前的<strong>策略Pi</strong>选择行为;</li><li>每个分身一直走到最终状态，并计算一路上获得的所有<strong>奖励总和</strong>;</li><li>我们计算每个影分身获得的<strong>平均值</strong>,这个平均值就是我们要求的V值。</li></ol><p>用大白话总结就是：<strong>从某个状态，按照策略 ，走到最终状态很多很多次；最终获得奖励总和的平均值，就是V值</strong>。</p><p><strong>【敲黑板！！！】</strong> </p><p>从V值的计算，我们可以知道，V值代表了这个状态的今后能获得奖励的期望。从这个状态出发，到达最终状态，平均而言能拿到多少奖励。所以我们可以轻易比较两个状态的价值。</p><p>V值跟我们选择的策略有很大的关系。 我们看这样一个简化的例子，从S出发，只有两种选择，A1，A2；从A1，A2只有一条路径到最终状态，获得总奖励分别为10和20。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgzfah8hzj60c308gjrf02.jpg"></p><p>现在我们假设策略采用<strong>平均策略</strong>[A1:50%,A2:50%]，根据用影分身(如果是学霸直接求期望)，那么我们可以求得V值为15</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgzhjwvrwj60sp04e0ty02.jpg"></p><p>现在我们改变策略[A1:60%,A2:40%]，那么我们可以求得V值为14，变少了！</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgzjqn3iqj60vf04gabb02.jpg"></p><p>所以大家看到，<strong>V值是会根据不同的策略有所变化的！</strong></p><h2 id="Q值的定义"><a href="#Q值的定义" class="headerlink" title="Q值的定义"></a>Q值的定义</h2><p>如果大家已经了解V值的定义，那么理解Q值也不会有什么困难。Q值和V值的概念是一致的，都是衡量在马尔可夫树上某一个节点的价值。只不过<strong>V值衡量的是状态节点的价值</strong>，而<strong>Q值衡量的是动作节点的价值</strong>。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvgzl63qz0j60ew0bgdg602.jpg"></p><p>和V值一样，我们也可以用影分身来理解Q值。</p><p>现在我们需要计算，某个状态S0下的一个动作A的Q值：</p><ol><li>我们就可以从A这个节点出发，使用影分身之术；</li><li>每个影分身走到最终状态,并记录所获得的奖励；</li><li>求取所有影分身获得奖励的平均值，这个平均值就是我们需要求的Q值。</li></ol><p>用大白话总结就是：<strong>从某个状态选取动作A，走到最终状态很多很多次；最终获得奖励总和的平均值，就是Q值</strong>。</p><p><strong>【敲黑板！！！】</strong></p><p><strong>与V值不同，Q值和策略并没有直接相关，而与环境的状态转移概率相关，而环境的状态转移概率是不变的。</strong></p><h2 id="V值和Q值关系"><a href="#V值和Q值关系" class="headerlink" title="V值和Q值关系"></a>V值和Q值关系</h2><p>总结一下，从以上的定义，我们可以知道Q值和V值的意义相通的： </p><ol><li>都是马尔可夫树上的节点；</li><li>价值评价的方式是一样的： 从当前节点出发，一直走到最终节点，所有的奖励的期望值</li></ol><p>所以，聪明的同学已经看出，<strong>Q和V之间是可以相互换算的</strong>。</p><h3 id="从Q到V：已知Q，求解V"><a href="#从Q到V：已知Q，求解V" class="headerlink" title="从Q到V：已知Q，求解V"></a>从Q到V：已知Q，求解V</h3><p>我们先来看看，怎样用Q值计算V值，已知Q，求解V。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh5pv2r6cj60is0dvdgx02.jpg"></p><p>从定义出发，我们要求的V值，就是从状态S出发，到最终获取的所获得的奖励总和的期望值。也就是蓝色框部分。</p><p>S状态下有若干个动作，每个动作的Q值，就是从这个动作之后所获得的奖励总和的期望值。也就是红色框部分。</p><p>假设我们已经计算出每个动作的Q值，那么在计算V值的时候就不需要一直走到最终状态了，只需要走到动作节点，看一下每个动作节点的Q值，根据策略 ，计算Q的期望就是V值了。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh5str943j60au0d73yt02.jpg"></p><p>正式的数学公式如下：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh5ts4s59j60ex06nq3202.jpg"></p><p>大白话就是：<strong>一个状态的V值，就是这个状态下的所有动作的Q值，在策略Pi下的期望</strong>。</p><h3 id="从V到Q：已知V，求解Q"><a href="#从V到Q：已知V，求解Q" class="headerlink" title="从V到Q：已知V，求解Q"></a>从V到Q：已知V，求解Q</h3><p>现在我们换个角度，看一下怎样从V换算成Q值。</p><p>道理还是一样，就是用Q就是V的期望！而且这里不需要关注策略，这里是环境的状态转移概率决定的。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh5xo45tdj609l0ebweu02.jpg"></p><p>对，但还差点东西。</p><p>【敲黑板！！！】 </p><p>当我们选择A，并转移到新的状态时，就能获得奖励，我们必须把这个<strong>奖励也算上！</strong></p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh5zguduvj60900anwep02.jpg"></p><p>正式的数学公式如下：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh72suh4mj60i1084glw02.jpg"></p><p><strong>折扣率</strong> 在强化学习中，有某些参数是人为<strong>主观</strong>制定。这些参数并不能推导，但在实际应用中却能解决问题，所以我们称这些参数为<strong>超参数</strong>，而折扣率就是一个超参数。 与金融产品说的贴现率是类似的。我们计算Q值，目的就是把未来很多步奖励，折算到当前节点。但未来n步的奖励的10点奖励，与当前的10点奖励是否完全等价呢？未必。所以我们人为地给未来的奖励一定的折扣，例如：0.9,0.8，然后在计算到当前的Q值。</p><h3 id="从V到V：已知V-s-求解V-s’"><a href="#从V到V：已知V-s-求解V-s’" class="headerlink" title="从V到V：已知V(s) ,求解V(s’)"></a>从V到V：已知V(s) ,求解V(s’)</h3><p>现在我们知道如何从V到Q，从Q到V了。但<strong>实际应用中，我们更多会从V到V</strong>。</p><p>但其实从V到V也是很简单的。把公式代进去就可以了。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89V%E5%80%BC%E5%92%8CQ%E5%80%BC/008i3skNly1gvh6d07ervj60nb0bf0te02.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>比起记住公式，其实我们更应该注意Q值和V值的意义：他们就像一个路牌一样，告诉我们从马尔可夫树的一个节点出发，下面所有节点的收获的期望值。也就是假设从这个节点开始，走许多许多次，最终获取的奖励的平均值。</li><li><strong>V就是子节点的Q的期望！但要注意V值和策略相关</strong>。<strong>（V值是子节点Q值与策略的期望）</strong></li><li><strong>Q就是子节点的V的期望！但要注意，记得把R计算在内</strong>。<strong>（Q值是子节点V值和状态转移概率的期望与奖励之和）</strong></li></ol><p>大家有没有发现，在这一节中，计算某一个节点的Q值和V值，需要许多次试验，取其中的平均值。但实际上，我们不但需要求一个节点的值，而是求所有节点的值。如果我们每一个节点都用同样的方法，消耗必然会很大。所以人们发明了许多方式去计算Q值和V值，基于价值计算的算法就是围绕Q和V展开的。这些在以后的文章将会说到。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/109498587">https://zhuanlan.zhihu.com/p/109498587</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>V值和Q值</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习（一）马尔可夫链</title>
    <link href="/2021/10/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/"/>
    <url>/2021/10/15/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>本系列文章属于强化学习领域，参考图片均保留水印来源，资料均来源于网络，在文末参考链接中已经注明。</p><span id="more"></span><h2 id="强化学习的学习路线"><a href="#强化学习的学习路线" class="headerlink" title="强化学习的学习路线"></a>强化学习的学习路线</h2><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg7z3buh4j60eg0ivmy302.jpg"></p><p>线路图分为两部分</p><ul><li>第一部分是基础概念；<br>首先我们要弄清楚强化学习到底是干嘛的？它围绕怎样一个问题，而后面所有的所有，都是围绕这个问题的解决方案。</li><li>第二部分是深度强化学习的算法；<br>他们是怎么一直发展的，脉络是怎样的？</li></ul><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><p>我们先来看马尔可夫链，它长这样子：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg81pr934j60n704idg002.jpg"></p><p>马尔可夫链描述的是智能体和环境进行互动的过程。简单说：智能体在一个状态(用S代表)下，选择了某个动作(用S代表)，进入了另外一个状态，并获得奖励(用R代表)的过程。</p><p>所以，我们希望通过让智能体在环境里获取<strong>最多的奖励</strong>，把智能体训练成我们想要的样子——就是能完成某些特定的任务。</p><p>所以，我们马上遇到第一个坑：马尔可夫链，其实应该叫马尔可夫树吧！</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg83gi8pbj60ap0d10ta02.jpg"></p><p>我们看到的链，是因为我们从现在往后看，但如果往前看，是充满不确定性的。</p><p>这里的不确定性包括两方面： </p><ul><li>策略：智能体的每次选择都不是固定的，而是按照一定的策略分布。这个概率分布我们称为<strong>策略</strong>，用Pi表示。 </li><li>状态转移概率：这个只跟环境有关系。例如飞行棋的掷骰子游戏，我们执行同样的动作，也有可能进入不同的状态。</li></ul><h2 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h2><p>首先我们需要明确，强化学习的任务是什么？ </p><p>这用大白话说：就是我们希望用强化学习的方式，使某个<strong>东东</strong>获得<strong>独立自主地完成某种任务</strong>的能力。</p><p>而这个<strong>东东，</strong>我们称为<strong>智能体</strong>。而智能体学习和工作的地方，我们就称为<strong>环境</strong>。</p><p>注意！所谓独立自主，就是智能体一旦启动，就不需要人指挥了。</p><p>例如说扫地机器人打开开关，就不需要人类告诉机器人哪里有灰尘，哪里有垃圾，自己就会去清理了； </p><p>又例如：自动驾驶汽车在导航设置好之后，就不再需要司机去操作，汽车能够自己安全到达目的地。</p><p>但我们应该怎样才能让智能体学会技能呢？</p><p>和我们研究其他的问题一样，我们首先需要把问题抽象称为模型。我们才能在这个模型进行实验和探索后，再把结果运用到实际当中去。</p><p><strong>马尔可夫链</strong>，就是对现实世界抽象的一个模型。因而马尔可夫链被广泛使用在各个领域，当然也包括我们讨论的强化学习领域。本强化学习专栏中提到的几乎所有的算法，都是基于马尔可夫链这个模型。我们必须了解问题是什么，才能更好解决问题。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg8ogmeo0j60n704idg002.jpg"></p><p>在马尔可夫链中，有三个重要的元素：S，A，R。我们分别来看一下，他们代表的是什么。然后大家就会明白，为什么马尔科夫链是一个很好很常用的模型。</p><h2 id="S（state）状态"><a href="#S（state）状态" class="headerlink" title="S（state）状态"></a><strong>S（state）状态</strong></h2><p>S（state）状态，在图中用白色圈圈表示。</p><p><strong>状态</strong>就是智能体<strong>观察</strong>到的当前环境的<strong>部分或者全部特征</strong>。</p><p>举个例子：无人驾驶汽车来到十字路口。和人类一样，它需要先“观察”这个路口的情况，再决定一下步的”动作”。</p><p>无人驾驶汽车通过摄像头，可以观察到交通标志、交通信号灯等情况；通过雷达，可以探测到与其他汽车、行人的距离；通过导航系统，了解前方的路段是否通畅等等。这些被观察到的环境特征，就是无人驾驶汽车的<strong>状态特征</strong>， <strong>状态空间</strong>就是智能体能够观察到的特征数量。</p><p>需要特别注意的是：环境的特征可能有许多，但只有智能体能够观察到的特征才算是状态。所以我们也用Observation（观察的英文）表示状态。</p><p>为什么要强调被观察呢？ </p><ol><li><p>这提醒我们要给智能体最有用的特征；因为在实际工作中，输入特征往往是很“贵”的，无人驾驶汽车的摄像头，雷达通常都是很昂贵的。而无用的特征，例如是否有乘客在唱歌之类的，输入到自动驾驶系统，这无疑加重了学习的负担。所以，我们必须非常慎重地选择状态特征。 </p></li><li><p>提醒我们要注意观察的角度。假设我们学有所成，希望做一个智能体学习如何打德州扑克。你就会突然发现，这个状态很微妙。因为对于每位玩家，都只看到自己的牌和公关牌，所以观察到的状态都是不一样的。</p></li></ol><p>但在新手期，我们会把重点放在算法中，大家在实际工作中留个心眼就好。</p><h2 id="A（action）动作"><a href="#A（action）动作" class="headerlink" title="A（action）动作"></a><strong>A（action）动作</strong></h2><p>A（action）动作,（用黑色圈圈表示）</p><p>动作其实不用解释，就是智能体做出的具体行为。例如扫地机器人会移动，吸尘，甚至喷水。无人驾驶汽车能够移动，加速，刹车，转弯等。</p><p><strong>动作空间</strong>就是该智能体能够做出的动作数量。</p><p>举个例子：智能体身处十字路口。那么我们的方向就有4个。也就是说，我们能做的动作，就是4个。我们称<strong>我们能做的动作的集合，称为动作空间</strong>。</p><h2 id="R（reward）奖励"><a href="#R（reward）奖励" class="headerlink" title="R（reward）奖励"></a><strong>R（reward）奖励</strong></h2><p>当我们在某个状态下，完成动作。环境就会给我们反馈，告诉我们这个动作的效果如何。这种效果的数值表达，就是<strong>奖励</strong>。</p><p>其实这里的reward翻译为“反馈”可能更合适一点。因为反馈并不是完全正面的，也有负面。（但为了和其他文献统一，方便大家学习，这里仍然写作“奖励”） 当奖励可以是正数，表示鼓励当前的行为；如果是负数负数，表示惩罚这种行为。当然也可以是0。 而奖励值的大小，表示鼓励的和惩罚的力度不同。</p><p>奖励在强化学习中，起到了很关键的作用，我们会以奖励作为引导，让智能体学习做能获得<strong>最多奖励</strong>的动作。</p><p>例如：我需要训练机器人打乒乓球。机器人每次赢球，都可以加分；输球，就减分。这分数就表现了机器人的动作好坏。如果机器人希望获得更多的分数，就需要想办法赢球。</p><p>又例如：无人驾驶汽车如果成功到达目标地点，那么可以获得奖励；但如果闯红灯，那么就会被扣除大量的奖励作为惩罚。如果无人驾驶汽车希望获得更多的分数，那么就必须在遵守交通规则的情况下，成功到达目标地点。</p><p>敲黑板：奖励的设定是<strong>主观</strong>的，也就是说我们为了智能体更好地学习工作，自己定的。所以大家可以看到，很多时候我们会对奖励进行一定的修正，这也是加速智能体学习的方法之一。</p><p>现在我们来总结一下马尔科夫链，其中也包含了强化学习的一般步骤：</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg9pso5u1j60i203b74d02.jpg"></p><ol><li>智能体在环境中，观察到状态(S)；</li><li>状态(S)被输入到智能体，智能体经过计算，选择动作(A); </li><li>动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体。 </li><li>智能体根据返回奖励(R)，调整自己的策略。 重复以上步骤，一步一步创造马尔可夫链。</li></ol><p>所以你看，强化学习跟教孩子是一个道理: 孩子做了好事，必须给奖励；孩子做错事了，必须惩罚。就这么简单！</p><h2 id="马尔可夫‘链’？"><a href="#马尔可夫‘链’？" class="headerlink" title="马尔可夫‘链’？"></a>马尔可夫‘链’？</h2><p>于是！于是我们就掉进第一个坑里了！ 在强化学习里，这根本不应该叫做‘<strong>链</strong>’而应该叫马尔可夫‘<strong>树</strong>’！</p><p>马尔可夫链之所以是我们现在看到的一条链条。是因为我们站在现在，往<strong>后</strong>看，所以是一条确定的路径。但如果我们往<strong>前</strong>看，就并不是一条路径，而是充满了各种“不确定性”。</p><p>这就像我们从家里到公司上班，中间有若干种上班的方式。现在你从家里出门，走过了两个路口，到了公交车站。 这时候往后看，从家到公交车站这一路，只能有一条路径。虽然你可以走其他路到公交车站，但这是你走过的路，已经确定下来了，所以路径只有一条；但如果往前看，从公交车坐车到公司，还有很多种方式到达，向前展开的是各种不确定性。</p><p>理解这一点很重要，这是理解强化学习理论的基础。为了更好理解，我们举个例子：</p><p>假设现在我们来玩这样一个游戏。这个游戏是简化版的大富翁，我们只考虑我们当前所处位置，也就是状态。智能体移动的时候，它可以选择投掷1-3个骰子，根据骰子点数的总和向前移动。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg9x8xxdoj30o409g74q.jpg"></p><p>现在，智能体从格子A掷骰子，并移动到格子B。其实经历了两次不确定性。</p><p>第一次，是“选择”的过程。智能体主动选择骰子的个数。掷骰子的个数不同，到达格子B的概率也不同。所以“选择”会影响到下一个状态。这种不同动作之间的选择，我们称为智能体的<strong>策略</strong>。策略我们一般用<strong>Pi</strong>表示。我们的任务就是找到一个策略，能够获得最多的奖励。</p><p>第二次的不确定性，是环境的随机性，这是智能体无法控制的。在这个例子里就是骰子的随机性。注意，并不是所有环境都有随机性，有些环境是很确定的（例如把以上所有骰子每一面都涂成1点），但马尔可夫链允许我们有不确定性的存在。</p><p>从上面的例子我们知道，这种不确定性来自两个方面：1.智能体的行动选择（策略）。2.环境的不确定性。</p><p><img src="%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/008i3skNly1gvg9ys7tzij60hi0fm0ty02.jpg" alt="马尔可夫树"></p><p>所以，如果以后有人闯红灯，然后还大条道理地说：闯红灯又不一定会死，等绿灯也有可能死呀！ 这时候你要做的，除了离SB远点以外，心里还要清楚：闯红灯和等绿灯是我的选择，但不同选择后面的环境随机性给出的概率是不一样的。虽然我不能控制环境的随机性，但我能控制我的选择，让我避免高风险的低回报的情况出现。 类似地，总会有人说不读书也能成功的话。想想背后的逻辑，你将会更清楚自己的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>马尔可夫链是用来描述智能体和环境互动的过程。</li><li>马尔可夫链包含三要素：state，action，reward</li></ol><ul><li>state：<strong>只有智能体能够观察到的才是state</strong>。</li><li>action：智能体的动作。</li><li>reward：引导智能体工作学习的主观的值。</li><li>马尔可夫链的不确定性</li><li>核心思想：如果你不希望孩子有某种行为，那么当这种行为出现的时候就进行惩罚。如果你希望孩子坚持某种行为，那么就进行奖励。这也是整个强化学习的核心思想。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/111869532">https://zhuanlan.zhihu.com/p/111869532</a></li><li><a href="https://zhuanlan.zhihu.com/p/109217883">https://zhuanlan.zhihu.com/p/109217883</a></li><li><a href="https://www.zhihu.com/people/zhang-si-jun-52">https://www.zhihu.com/people/zhang-si-jun-52</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马尔可夫链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python并发编程【已完结】</title>
    <link href="/2021/09/23/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/09/23/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>为什么要引入并发编程? 引入并发编程，就是为了提升程序运行速度，减少用户等待时间，优化用户体验。</p><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>视频课：<a href="https://www.bilibili.com/video/BV1bK411A7tV?p=1">https://www.bilibili.com/video/BV1bK411A7tV?p=1</a></p><h3 id="1-为什么要引入并发编程"><a href="#1-为什么要引入并发编程" class="headerlink" title="1.为什么要引入并发编程?"></a>1.为什么要引入并发编程?</h3><p>引入并发编程，就是为了提升程序运行速度，减少用户等待时间，优化用户体验。</p><h3 id="2-程序提速的方法"><a href="#2-程序提速的方法" class="headerlink" title="2.程序提速的方法"></a>2.程序提速的方法</h3><h4 id="2-1单线程串行"><a href="#2-1单线程串行" class="headerlink" title="2.1单线程串行"></a>2.1单线程串行</h4><p>执行模式：首先CPU计算处理，然后IO进行读写，CPU、IO、CPU…如此依次交替单线程串行执行。当CPU处理时，IO空闲等待；当IO读写时，CPU空闲等待。这种执行模式，浪费了空闲时间，使得执行程序的效率变低。</p><p>粒度：一个CPU一条线，交替执行</p><h4 id="2-2多线程并发"><a href="#2-2多线程并发" class="headerlink" title="2.2多线程并发"></a>2.2多线程并发</h4><p>一台计算机的CPU和IO是可以同时并行工作的，因此多线程并发可以充分利用CPU和IO的使用资源。</p><p>执行模式：当执行某一线程A时，CPU在计算处理，如果其他线程B遇到了IO读写操作，此时本应空闲等待线程A的 IO操作，会切换到另外一个任务执行线程B的IO读写。这样以来，CPU和IO会在不同的线程上同时保持工作状态。从整体上看，计算机的CPU和IO始终是处于工作状态，大大提高了执行程序的速度。</p><p>粒度：一个CPU多条线，并发执行</p><p><strong>调用：threading</strong></p><h4 id="2-3多CPU并行"><a href="#2-3多CPU并行" class="headerlink" title="2.3多CPU并行"></a>2.3多CPU并行</h4><p>当前的计算机通常都是多核CPU，因此，我们可以实现多个CPU多条线程同时真正的并行执行来达到加速的效果。</p><p>执行模式：扩展多线程并发中的CPU数量，转化成多CPU多线程的加速执行模式。</p><p>粒度：多个CPU多条线，并行执行</p><p><strong>调用：multiprocessing</strong></p><h4 id="2-4多机器并行"><a href="#2-4多机器并行" class="headerlink" title="2.4多机器并行"></a>2.4多机器并行</h4><p>多机器的并行思路是进一步增加CPU的数量，并行执行</p><p>执行模式：多个计算机并行执行计算任务</p><p>粒度：多个机器（即多个CPU）多条线，并行执行</p><p>调用：hadoop/hive/spark</p><p><strong>注：串行：单核单线            并发：单核多线            并行：多核多线</strong></p><h4 id="2-5图解对比"><a href="#2-5图解对比" class="headerlink" title="2.5图解对比"></a>2.5图解对比</h4><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0ysa60v8j61yy0tsgq302.jpg"></p><h3 id="3-Python对并发编程的支持"><a href="#3-Python对并发编程的支持" class="headerlink" title="3.Python对并发编程的支持"></a>3.Python对并发编程的支持</h3><ul><li>多线程：threading模块，利用CPU和IO可以同时执行的原理，让CPU不会干巴巴空闲等待IO完成。</li><li>多进程：multiprocessing模块，利用多核CPU的能力，真正的并行执行任务。</li><li>异步IO：asyncio模块，在<strong>单线程</strong>利用CPU和IO同时执行的原理，实现函数异步执行。</li></ul><ul><li>可以使用Lock对共享资源加锁，防止冲突访问。</li><li>可以使用Queue实现不同线程/进程之间的数据通信，实现生产者和消费者模式。</li><li>可以使用线程池Pool/进程池Pool，简化线程/进程的任务提交、等待结束、获取结果。</li><li>可以使用subprocess启动外部程序的进程，并进行输入输出的交互。如：可以使用subprocess调用启动事先写好的.exe程序，并与它进行输入输出交互，实现交互式的进程通信。</li></ul><h3 id="4-Python并发编程的类型"><a href="#4-Python并发编程的类型" class="headerlink" title="4.Python并发编程的类型"></a>4.Python并发编程的类型</h3><p>一个进程中可以启动N个线程，一个线程中可以启动N个协程。</p><h4 id="4-1多进程Process（multiprocessing）"><a href="#4-1多进程Process（multiprocessing）" class="headerlink" title="4.1多进程Process（multiprocessing）"></a>4.1多进程Process（multiprocessing）</h4><p>优点：<strong>可以利用多核CPU并行运算</strong></p><p>缺点：占用资源最多、可启动数目比线程少</p><p>适用于：CPU密集型计算</p><h4 id="4-2多线程Thread（Threading）"><a href="#4-2多线程Thread（Threading）" class="headerlink" title="4.2多线程Thread（Threading）"></a>4.2多线程Thread（Threading）</h4><p>优点：相比进程，更加轻量级、占用资源少</p><p>缺点：相比进程，多线程只能并发执行，不能利用多CPU（GIL）</p><p>​            相比协程，启动数目有限制，占用内存资源，有线程切换开销</p><p>适用于：IO密集型计算，同时运行的任务数目要求不多</p><h4 id="4-3多协程Coroutine（asyncio）"><a href="#4-3多协程Coroutine（asyncio）" class="headerlink" title="4.3多协程Coroutine（asyncio）"></a>4.3多协程Coroutine（asyncio）</h4><p>优点：内存开销最少、启动协程数目最多</p><p>缺点：支持的库有限制（aiohttp vs requests ）、代码实现复杂</p><p>适用于：IO密集型计算、需要超多任务运行、但是要有现成的协程库支持的场景</p><h3 id="5-CPU密集型计算与IO密集型计算"><a href="#5-CPU密集型计算与IO密集型计算" class="headerlink" title="5.CPU密集型计算与IO密集型计算"></a>5.CPU密集型计算与IO密集型计算</h3><h4 id="5-1CPU密集型（CPU-bound）"><a href="#5-1CPU密集型（CPU-bound）" class="headerlink" title="5.1CPU密集型（CPU- bound）"></a>5.1CPU密集型（CPU- bound）</h4><p>CPU密集型也叫计算密集型，是指I/O在很短的时间内就可以完成，CPU需要大量的计算和处理，特点是CPU占用率相当高，I/O操作很少。</p><p>例如：压缩与解压缩、加密与解密、正则表达式的搜索</p><h4 id="5-2IO密集型（IO-bound）"><a href="#5-2IO密集型（IO-bound）" class="headerlink" title="5.2IO密集型（IO- bound）"></a>5.2IO密集型（IO- bound）</h4><p>IO密集型指的是系统运作大部分的状况是在CPU等待I/O（硬盘/内存）的读/写操作，特点是I/O读写操作很频繁，CPU占用率很低。</p><p>例如：文件处理程序、网络爬虫程序、读写数据库程序</p><h3 id="6-技术选择"><a href="#6-技术选择" class="headerlink" title="6.技术选择"></a>6.技术选择</h3><p>对象：待执行任务</p><p>特点：1.CPU密集型    2.IO密集型</p><p>1.选择多进程（multiprocessing）技术方法</p><p>2.是否超多任务量&amp;是否有现成的协程库&amp;协程实现的复杂度可接受</p><p>2.1 否：选择多线程（threading）技术方法</p><p>2.2 是：选择多协程（asyncio）技术方法</p><h3 id="7-全局解释器锁GIL"><a href="#7-全局解释器锁GIL" class="headerlink" title="7.全局解释器锁GIL"></a>7.全局解释器锁GIL</h3><h4 id="7-1Python速度慢的原因"><a href="#7-1Python速度慢的原因" class="headerlink" title="7.1Python速度慢的原因"></a>7.1Python速度慢的原因</h4><p>相比C/C++/Java，Python确实比较慢，在一些特殊场景下，Python比C++慢了100～200倍。基于此种原因，各大公司的推荐引擎、搜索引擎、存储引擎等底层对性能要求较高的模块和基础架构的代码依然采用C/C++开发。</p><ul><li>原因1:动态类型语言，边解释边执行</li><li>原因2:由于存在GIL，所以Python无法利用多核CPU并发执行</li></ul><h4 id="7-2GIL是什么"><a href="#7-2GIL是什么" class="headerlink" title="7.2GIL是什么?"></a>7.2GIL是什么?</h4><p>全局解释器锁，Global Interpreter Lock缩写为GIL。它是计算仅程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便是在多核心CPU上，使用GIL的解释器也只允许同一时间执行一个线程。</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0ytdph7nj61a80oiq5l02.jpg"></p><ul><li>当一个线程运行时，它会持有GIL（获取了GIL，线程才能运行）</li><li>当一个线程遇到I/O操作时，它会释放GIL</li><li>由于GIL的机制存在，即使是多核CPU，单个时刻也只能使用1个CPU</li></ul><h4 id="7-3规避GIL的限制"><a href="#7-3规避GIL的限制" class="headerlink" title="7.3规避GIL的限制"></a>7.3规避GIL的限制</h4><ul><li><p>多线程threading机制依然是有用的，用于IO密集型计算</p><p>因为在I/O操作期间，线程会释放GIL，实现CPU和IO的并行。因此，多线程应用于IO密集型计算可以大幅度提升速度。</p><p><strong>但是多线程如果应用于CPU密集型计算时，只会拖慢速度。</strong></p></li><li><p>利用多核CPU的优势使用multiprocessing的多进程机制实现并行计算</p><p>为了应对GIL的问题，Python提供了multiprocessing</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-创建多线程"><a href="#1-创建多线程" class="headerlink" title="1.创建多线程"></a>1.创建多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.准备一个函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_func</span>(<span class="hljs-params">a,b</span>):<br>  <span class="hljs-built_in">print</span>(a,b)<br>  <br><span class="hljs-comment">#2.创建线程：将函数封装到线程中</span><br><span class="hljs-keyword">import</span> threading<br>t = threading.Thread(target=my_func,args=(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,))<br><span class="hljs-comment">#参数target后加上函数名字，注意没有括号和函数的参数</span><br><span class="hljs-comment">#参数args是一个元组类型，代指参数target中的函数的参数</span><br><span class="hljs-comment">#元组数据类型最后一个元素后面最好带一个,(逗号)以区别字符串，当然可以省略</span><br>                     <br><span class="hljs-comment">#3.启动线程</span><br>t.start()<br>                     <br><span class="hljs-comment">#4.等待结束</span><br>t.join()<br></code></pre></td></tr></table></figure><h4 id="1-1单线程和多线程速度对比"><a href="#1-1单线程和多线程速度对比" class="headerlink" title="1.1单线程和多线程速度对比"></a>1.1单线程和多线程速度对比</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#文件名：BlogRequest</span><br><span class="hljs-keyword">import</span> requests<br><br>hearders = &#123;<br><span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15&quot;</span><br>&#125;<br><br>url_list = [<br>    <span class="hljs-string">f&quot;https://www.cnblogs.com/cate/python/#p<span class="hljs-subst">&#123;page&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>)<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">requset</span>(<span class="hljs-params">url</span>):<br>    page_text = requests.get(url=url,headers=hearders).text<br>    <span class="hljs-built_in">print</span>(url,<span class="hljs-built_in">len</span>(page_text))<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> BlogRequest<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">single_threading</span>():<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> BlogRequest.url_list:<br>        BlogRequest.requset(url)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_threading</span>():<br>  <span class="hljs-comment">#为每一个请求建立一个线程</span><br>    threads = []<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> BlogRequest.url_list:<br>        t = threading.Thread(target=BlogRequest.requset, args=(url,))<br>        threads.append(t)<br><br>    <span class="hljs-comment">#开启所有线程</span><br>    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>        thread.start()<br><span class="hljs-comment">#等待结束所有线程</span><br>    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>        thread.join()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    start = time.time()<br>    single_threading()<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;single_threading:&quot;</span>,end-start,<span class="hljs-string">&quot;second&quot;</span>)<br><br>    start = time.time()<br>    multi_threading()<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;multi_threading:&quot;</span>,end-start,<span class="hljs-string">&quot;second&quot;</span>)<br><br><span class="hljs-comment">#single_threading: 22.938573837280273 second</span><br><span class="hljs-comment">#顺序执行（串行执行）</span><br><span class="hljs-comment">#multi_threading: 1.4568729400634766 second</span><br><span class="hljs-comment">#多线程并发执行，随机结束</span><br></code></pre></td></tr></table></figure><h3 id="2-生产者消费者模型"><a href="#2-生产者消费者模型" class="headerlink" title="2.生产者消费者模型"></a>2.生产者消费者模型</h3><h4 id="2-1多组件的Pipeline技术架构"><a href="#2-1多组件的Pipeline技术架构" class="headerlink" title="2.1多组件的Pipeline技术架构"></a>2.1多组件的Pipeline技术架构</h4><p>复杂的事情一般都不会一下子做完，而是会分成很多中间步骤一步一步地完成。</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yu00uucj61uy0piadu02.jpg"></p><p>当Processor数量只有两个时，对应的就是生产者和消费者架构（模型）。以爬虫为例：</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yuhnp8sj61y20pitca02.jpg"></p><p>这样做的好处是，将生产者和消费者的开发任务进行分开，通过中间数据队列进行数据交互。生产者和消费者中间的数据队列需要用到多线程的数据通信的<code>queue.Queue</code>。</p><h4 id="2-2多线程的数据通信的queue-Queue"><a href="#2-2多线程的数据通信的queue-Queue" class="headerlink" title="2.2多线程的数据通信的queue.Queue"></a>2.2多线程的数据通信的queue.Queue</h4><p><code>queue.Queue</code>可以用于多线程之间的、<strong>线程安全</strong>的数据通信。其中，<strong>线程安全指的是多个线程并发同时访问队列中的数据时，不会出现数据冲突。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.导入类库</span><br><span class="hljs-keyword">import</span> queue<br><br><span class="hljs-comment">#2.创建Queue对象q</span><br>q = queue.Queue()<br><br><span class="hljs-comment">#3.添加数据元素item</span><br>q.put(item)<br><br><span class="hljs-comment">#4.获取队首数据元素</span><br>q.get()<br><br>注：put()和get()方法都是阻塞的。<br>使用put()方法时，当队列状态满时，put()方法会卡住，直到队列中有空闲位置时，才能添加进去数据元素；<br>使用get()方法时，当队列状态空时，get()方法会卡住，直到队列中有数据元素时，才能去到数据元素。<br><br><span class="hljs-comment">#5.查询队列状态</span><br><span class="hljs-comment">#查看队列中数据元素的数量</span><br>q.qsize()<br><span class="hljs-comment">#判断队列是否为空</span><br>q.empty()<br><span class="hljs-comment">#判断队列是否为满</span><br>q.full()<br></code></pre></td></tr></table></figure><p>爬取博客园的生产者和消费者模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#文件名：BlogRequest</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><br>url_list = [<br>    <span class="hljs-string">f&quot;https://www.cnblogs.com/cate/python/<span class="hljs-subst">&#123;page&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>)<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15&quot;</span><br>    &#125;<br>    html = requests.get(url=url,headers=headers).text<br>    <span class="hljs-keyword">return</span> html<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>):<br>    tree = etree.HTML(html)<br>    article_list = tree.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;post_list&quot;]/article&#x27;</span>)<br>    <span class="hljs-comment"># href_list = []</span><br>    <span class="hljs-comment"># title_list = []</span><br>    <span class="hljs-comment"># for art_li in article_list:</span><br>        <span class="hljs-comment"># href_list.append(art_li.xpath(&#x27;.//div/a/@href&#x27;)[0])</span><br>        <span class="hljs-comment"># title_list.append(art_li.xpath(&#x27;.//div/a/text()&#x27;)[0])</span><br>    <span class="hljs-keyword">return</span> [(art_li.xpath(<span class="hljs-string">&#x27;.//div/a/@href&#x27;</span>)[<span class="hljs-number">0</span>],art_li.xpath(<span class="hljs-string">&#x27;.//div/a/text()&#x27;</span>)[<span class="hljs-number">0</span>])<span class="hljs-keyword">for</span> art_li <span class="hljs-keyword">in</span> article_list]<br></code></pre></td></tr></table></figure><p>注意：<code>url_list</code>变量中的每一个<code>url</code>，并不是浏览器直观的写在地址栏中的<code>url</code>:<code>https://www.cnblogs.com/cate/python/#p3</code>，而是需要借助抓包工具抓取到真实的请求地址<code>https://www.cnblogs.com/cate/python/&#123;page&#125;</code>，如图：</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yusg20aj61ov0u0nbk02.jpg"></p><p><strong>具体原理可自行学习HTML的相关知识，这里只做避坑处理。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> BlogRequest<br><span class="hljs-keyword">import</span> queue<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">producer_request</span>(<span class="hljs-params">url_queue:queue.Queue,html_queue:queue.Queue</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        url = url_queue.get()<br>        html = BlogRequest.request(url)<br>        html_queue.put(html)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生产者线程名：&quot;</span>,threading.current_thread().getName(),<span class="hljs-string">f&quot;爬取的地址是<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>,<br>              <span class="hljs-string">&quot;地址队列中的地址数量：&quot;</span>,url_queue.qsize())<br>        time.sleep(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer_parse</span>(<span class="hljs-params">html_queue:queue.Queue,fout</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        html = html_queue.get()<br>        results = BlogRequest.parse(html)<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> results:<br>            fout.write(<span class="hljs-built_in">str</span>(data) + <span class="hljs-string">&quot;\n&quot;</span>)<br>        <span class="hljs-comment">#获取当前线程的名字</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;消费者线程名：&quot;</span>,threading.current_thread().getName(),<span class="hljs-string">f&quot;results数据的数量<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(results)&#125;</span>&quot;</span>,<br>              <span class="hljs-string">&quot;网页队列中的网页数量：&quot;</span>,html_queue.qsize())<br>        time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    url_queue = queue.Queue()<br>    html_queue = queue.Queue()<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> BlogRequest.url_list:<br>        url_queue.put(url)<br><br>    <span class="hljs-comment">#创建3个生产者线程：</span><br>    <span class="hljs-keyword">for</span> threading_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>):<br>        t = threading.Thread(target=producer_request,args=(url_queue,html_queue,),name=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;threading_id&#125;</span>&quot;</span>)<br>        t.start()<br><br>    <span class="hljs-comment">#创建2个消费者线程：</span><br>    fout = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)<br>    <span class="hljs-keyword">for</span> threading_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>):<br>        t = threading.Thread(target=consumer_parse,args=(html_queue,fout,),name=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;threading_id&#125;</span>&quot;</span>)<br>        t.start()<br></code></pre></td></tr></table></figure><h3 id="3-线程安全问题"><a href="#3-线程安全问题" class="headerlink" title="3.线程安全问题"></a>3.线程安全问题</h3><h4 id="3-1线程安全的概念"><a href="#3-1线程安全的概念" class="headerlink" title="3.1线程安全的概念"></a>3.1线程安全的概念</h4><p><strong>线程安全</strong>指的是某个函数、函数库<strong>在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量</strong>，使程序能够正确地完成执行。</p><p>由于<strong>线程的执行随时会发生切换</strong>，就造成了不可预料的结果，出现线程不安全的问题。以下面的银行取钱函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMoney</span>(<span class="hljs-params">account,amount</span>):<span class="hljs-comment">#L1</span><br>  <br>  <span class="hljs-keyword">if</span> account.balance &gt;= amount:<span class="hljs-comment">#L2</span><br>    <br>    account.balance -= amount<span class="hljs-comment">#L3</span><br><br></code></pre></td></tr></table></figure><p>假设账户余额为1000元，用户要取出800元。现在有两个线程<code>T1</code>和<code>T2</code>，当<code>T1</code>执行完取钱函数<code>#L2</code>位置时（已经判定条件<code>if account.balance &gt;= amount:</code>为真了，但是还未执行<code>#L3</code>，即账户余额仍为1000元），此时线程切换到<code>T2</code>执行取钱函数，取完800元后，<code>T2</code>执行完毕切换到<code>T1</code>，<code>T1</code>从刚才切换的位置继续执行，取走800元，最终账户余额-600元。</p><h4 id="3-2Lock解决线程安全问题"><a href="#3-2Lock解决线程安全问题" class="headerlink" title="3.2Lock解决线程安全问题"></a>3.2Lock解决线程安全问题</h4><h5 id="3-2-1try-finally模式"><a href="#3-2-1try-finally模式" class="headerlink" title="3.2.1try-finally模式"></a>3.2.1try-finally模式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-comment">#创建Lock锁对象lock</span><br>lock = threading.Lock()<br><br><span class="hljs-comment">#上锁</span><br>lock.acquire()<br><br><span class="hljs-keyword">try</span>:<br>  <span class="hljs-comment">#do something</span><br><span class="hljs-keyword">finally</span>:<br>  lock.release()<br></code></pre></td></tr></table></figure><h5 id="3-2-2with模式"><a href="#3-2-2with模式" class="headerlink" title="3.2.2with模式"></a>3.2.2with模式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-comment">#创建Lock锁对象lock</span><br>lock = threading.Lock()<br><br><span class="hljs-comment">#with 锁对象:</span><br><span class="hljs-keyword">with</span> lock:<br>  <span class="hljs-comment">#do something</span><br></code></pre></td></tr></table></figure><h4 id="3-3实战案例"><a href="#3-3实战案例" class="headerlink" title="3.3实战案例"></a>3.3实战案例</h4><p>未加线程锁的案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,balance</span>):<br>        self.balance = balance<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMoney</span>(<span class="hljs-params">account,amount</span>):<br>    <span class="hljs-keyword">if</span> account.balance &gt;= amount:<br>        <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;取钱成功！&quot;</span>)<br>        account.balance -= amount<br>        <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;余额：&quot;</span>,account.balance)<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;余额不足，取钱失败！&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    account = Account(<span class="hljs-number">1000</span>)<br>    T1 = threading.Thread(name=<span class="hljs-string">&#x27;T1&#x27;</span>,target=getMoney,args=(account,<span class="hljs-number">800</span>,))<br>    T2 = threading.Thread(name=<span class="hljs-string">&#x27;T2&#x27;</span>,target=getMoney,args=(account,<span class="hljs-number">800</span>,))<br>    T1.start()<br>    T2.start()<br></code></pre></td></tr></table></figure><p><strong>注：由于线程切换的随机性，因此该程序结果的出错现象是不固定的。</strong></p><p>加入<code>time.sleep()</code>函数，该函数阻塞当前线程，会发生线程切换。同时，<code>time.sleep()</code>函数相当于一个IO操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,balance</span>):<br>        self.balance = balance<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMoney</span>(<span class="hljs-params">account,amount</span>):<br>    <span class="hljs-keyword">if</span> account.balance &gt;= amount:<br>        time.sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment">#加入sleep，线程切换，一定出错</span><br>        <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;取钱成功！&quot;</span>)<br>        account.balance -= amount<br>        <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;余额：&quot;</span>,account.balance)<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;余额不足，取钱失败！&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    account = Account(<span class="hljs-number">1000</span>)<br>    T1 = threading.Thread(name=<span class="hljs-string">&#x27;T1&#x27;</span>,target=getMoney,args=(account,<span class="hljs-number">800</span>,))<br>    T2 = threading.Thread(name=<span class="hljs-string">&#x27;T2&#x27;</span>,target=getMoney,args=(account,<span class="hljs-number">800</span>,))<br>    T1.start()<br>    T2.start()<br></code></pre></td></tr></table></figure><p>加入线程锁，线程会正确执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>lock = threading.Lock()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,balance</span>):<br>        self.balance = balance<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMoney</span>(<span class="hljs-params">account,amount</span>):<br>    <span class="hljs-keyword">with</span> lock:<br>        <span class="hljs-keyword">if</span> account.balance &gt;= amount:<br>            time.sleep(<span class="hljs-number">0.1</span>)<br>            <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;取钱成功！&quot;</span>)<br>            account.balance -= amount<br>            <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;余额：&quot;</span>,account.balance)<br><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(threading.current_thread().getName(),<span class="hljs-string">&quot;余额不足，取钱失败！&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    account = Account(<span class="hljs-number">1000</span>)<br>    T1 = threading.Thread(name=<span class="hljs-string">&#x27;T1&#x27;</span>,target=getMoney,args=(account,<span class="hljs-number">800</span>,))<br>    T2 = threading.Thread(name=<span class="hljs-string">&#x27;T2&#x27;</span>,target=getMoney,args=(account,<span class="hljs-number">800</span>,))<br>    T1.start()<br>    T2.start()<br></code></pre></td></tr></table></figure><p>锁住线程之间的共享数据，只有拥有锁的线程，才能完整的执行锁住的代码。即使time.sleep()函数导致线程切换，但是没有锁的线程无法执行代码，所以依然会切换到有锁的线程。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="1-线程池的原理"><a href="#1-线程池的原理" class="headerlink" title="1.线程池的原理"></a>1.线程池的原理</h3><h4 id="1-1线程的生命周期"><a href="#1-1线程的生命周期" class="headerlink" title="1.1线程的生命周期"></a>1.1线程的生命周期</h4><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yv6zw3mj610e0u0mz102.jpg"></p><p>一个线程的状态包括：<strong>新建、就绪、运行、阻塞、终止</strong>五种状态。</p><ul><li><strong>新建状态</strong>的线程处于完全不动的状态，<strong>调用start方法进入就绪状态</strong>；</li><li><strong>就绪状态</strong>的线程在经过系统调度后，<strong>获得CPU资源进入运行状态</strong>；</li><li><strong>运行状态</strong>的线程<strong>可能会再次失去CPU资源而进入就绪状态</strong>，<strong>也可能遇到sleep/io，进入阻塞状态</strong>，<strong>也可能执行完run方法后进入终止状态</strong>；</li><li><strong>阻塞状态</strong>的线程<strong>当sleep/io结束后，会进入就绪状态</strong>，等待系统调度。</li></ul><h4 id="1-2原理"><a href="#1-2原理" class="headerlink" title="1.2原理"></a>1.2原理</h4><p>其中，新建线程需要系统分配资源，终止线程需要系统回收资源。如果大量的新建和终止线程，则需要大量的开销。<strong>如果可以重用线程，则可以节省（减去）新建/终止的开销。</strong>基于这种目的，线程池的流转如下图：</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yvg6cy4j610k0p60ug02.jpg"></p><p>上图主要有两部分组成：<strong>线程池</strong>和<strong>任务</strong>。其中，</p><ul><li>线程池中是<strong>预先创建</strong>的若干<strong>可以重用</strong>的线程。</li><li>任务队列用来存放新任务，线程池中的线程从任务队列中取任务，任务队列充当着新任务和线程之间的分配桥梁。</li><li>线程池中的线程执行完任务后，并不销毁，而是重用放回线程池中等待从任务队列中的下一个任务到来。</li></ul><h3 id="2-使用线程池的好处"><a href="#2-使用线程池的好处" class="headerlink" title="2.使用线程池的好处"></a>2.使用线程池的好处</h3><ul><li>提升性能：因为节省（减去）了大量新建、终止线程的开销，重用了线程资源。</li><li>适用场景：适用于处理突发性大量请求或者是需要大量线程，但每个线程处理任务的时间较短。</li><li>防御功能：因为线程池中预先创建的线程数量是提前声明的，这样能有效避免系统因为创建线程过多，而导致系统负荷过大反而被拖慢等问题。</li><li>代码优势：使用线程池的语法要比自己新建线程并执行线程的语法更加简洁。</li></ul><h3 id="3-ThreadPoolExecutor的使用方法"><a href="#3-ThreadPoolExecutor的使用方法" class="headerlink" title="3.ThreadPoolExecutor的使用方法"></a>3.ThreadPoolExecutor的使用方法</h3><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yvmrp25j61qn0u0q8502.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor,as_completed<br></code></pre></td></tr></table></figure><p>用法1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>  <br>  <span class="hljs-comment">#results是结果列表，与url_list是列表元素顺序对应</span><br>  results = pool.<span class="hljs-built_in">map</span>(request,url_list)<span class="hljs-comment">#url_list是列表</span><br>  <br>  <br>  <span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>用法2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>  <br>  <span class="hljs-comment">#submit更加灵活</span><br>  futures = [ pool.submit(request,url) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> url_list ]<br>  <br>  <span class="hljs-comment">#按照url对应的顺序挨个获取结果</span><br>  <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>    <span class="hljs-built_in">print</span>(future.result())<br>    <br>  <span class="hljs-comment">#加入as_completed，实现谁先完成谁先返回，得到结果</span><br>  <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(futures):<br>    <span class="hljs-built_in">print</span>(future.result())<br></code></pre></td></tr></table></figure><h3 id="4-实战案例"><a href="#4-实战案例" class="headerlink" title="4.实战案例"></a>4.实战案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#文件名：BolgRequest</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><br>url_list = [<br>    <span class="hljs-string">f&quot;https://www.cnblogs.com/cate/python/<span class="hljs-subst">&#123;page&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>)<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15&quot;</span><br>    &#125;<br>    html = requests.get(url=url,headers=headers).text<br>    <span class="hljs-keyword">return</span> html<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>):<br>    tree = etree.HTML(html)<br>    article_list = tree.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;post_list&quot;]/article&#x27;</span>)<br>    <span class="hljs-comment"># href_list = []</span><br>    <span class="hljs-comment"># title_list = []</span><br>    <span class="hljs-comment"># for art_li in article_list:</span><br>        <span class="hljs-comment"># href_list.append(art_li.xpath(&#x27;.//div/a/@href&#x27;)[0])</span><br>        <span class="hljs-comment"># title_list.append(art_li.xpath(&#x27;.//div/a/text()&#x27;)[0])</span><br>    <span class="hljs-keyword">return</span> [(art_li.xpath(<span class="hljs-string">&#x27;.//div/a/@href&#x27;</span>)[<span class="hljs-number">0</span>],art_li.xpath(<span class="hljs-string">&#x27;.//div/a/text()&#x27;</span>)[<span class="hljs-number">0</span>])<span class="hljs-keyword">for</span> art_li <span class="hljs-keyword">in</span> article_list]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> BlogRequest<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-comment">#抓取网页的线程池</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>        htmls = pool.<span class="hljs-built_in">map</span>(BlogRequest.request,BlogRequest.url_list)<br>        htmls = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(BlogRequest.url_list,htmls))                   <span class="hljs-comment">#zip()函数下面会补充说明用法</span><br>        <span class="hljs-keyword">for</span> url,html <span class="hljs-keyword">in</span> htmls:<br>            <span class="hljs-built_in">print</span>(url,<span class="hljs-built_in">len</span>(html))<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取网页完毕！&quot;</span>)<br><br>    <span class="hljs-comment">#解析网页的线程池</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>        futures = &#123;&#125;<br>        <span class="hljs-keyword">for</span> url,html <span class="hljs-keyword">in</span> htmls:<br>            future = pool.submit(BlogRequest.parse,html)<br>            futures[future] = url<br><br>        <span class="hljs-comment">#按照url对应的顺序挨个获取结果</span><br>        <span class="hljs-comment"># for future,url in futures.items():</span><br>        <span class="hljs-comment">#     print(url,future.result())</span><br><br>        <span class="hljs-comment">#注：这种方法是错误的，as_completed()参数是函数名</span><br>        <span class="hljs-comment"># 加入as_completed，实现谁先完成谁先返回，得到结果</span><br>        <span class="hljs-comment"># for url,future in as_completed(futures.items()):</span><br>        <span class="hljs-comment">#     print(url,future.result())</span><br><br>        <br>        <span class="hljs-comment"># 加入as_completed，实现谁先完成谁先返回，得到结果</span><br>        <span class="hljs-comment">#推荐这种方法as_completed()</span><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(futures):<br>            url = futures[future]<br>            <span class="hljs-built_in">print</span>(url,future.result())<br></code></pre></td></tr></table></figure><p>注：zip()函数</p><p>用法：zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。*<em>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表*</em>。</p><p>语法：zip([iterable, …])    参数说明：iterabl – 一个或多个迭代器    返回元组列表</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br><span class="hljs-meta">&gt;&gt;&gt; </span>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] <br><span class="hljs-meta">&gt;&gt;&gt; </span>c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>] <br><span class="hljs-meta">&gt;&gt;&gt; </span>zipped = <span class="hljs-built_in">zip</span>(a,b) <span class="hljs-comment"># 打包为元组的列表 </span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)] <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">zip</span>(a,c) <span class="hljs-comment"># 元素个数与最短的列表一致 </span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)] <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">zip</span>(*zipped) <span class="hljs-comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式 [(1, 2, 3), (4, 5, 6)]</span><br></code></pre></td></tr></table></figure><h3 id="5-线程池在Web服务中的应用"><a href="#5-线程池在Web服务中的应用" class="headerlink" title="5.线程池在Web服务中的应用"></a>5.线程池在Web服务中的应用</h3><h4 id="5-1Web服务的架构以及特点"><a href="#5-1Web服务的架构以及特点" class="headerlink" title="5.1Web服务的架构以及特点"></a>5.1Web服务的架构以及特点</h4><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yvv148cj61sq0katb202.jpg"></p><ol><li>Web浏览器会将请求发送给Web服务器（基于Flask或者Django框架）</li><li>Web服务器通常做三个IO操作：读取磁盘文件、读取数据库、读取远程服务API</li><li>Web服务器将读取的数据组合返回给Web浏览器</li></ol><p>特点：</p><ul><li>Web服务对响应时间要求比较高，通常在200ms内返回</li><li>Web服务有大量的依赖IO操作的调用，如：读取磁盘文件、数据库和远程服务API</li><li>Web服务经常需要处理万及百万级的同时请求，但服务器无法无限制创建线程，因为线程的创建和启动需要耗费资源</li></ul><h4 id="5-2使用线程池ThreadPoolExecutor加速"><a href="#5-2使用线程池ThreadPoolExecutor加速" class="headerlink" title="5.2使用线程池ThreadPoolExecutor加速"></a>5.2使用线程池ThreadPoolExecutor加速</h4><p>使用线程池ThreadPoolExecutor的好处：</p><ul><li>方便将磁盘文件、数据库和远程API的IO调用并发执行</li><li>线程池的线程数据是预先声明的，不会无限创建而导致系统崩溃，具有防御功能</li></ul><h4 id="5-3实战案例：基于Flask框架的WEb服务加速"><a href="#5-3实战案例：基于Flask框架的WEb服务加速" class="headerlink" title="5.3实战案例：基于Flask框架的WEb服务加速"></a>5.3实战案例：基于Flask框架的WEb服务加速</h4><p>未引入线程池：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> flask<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span>  time<br><br><span class="hljs-comment">#创建一个服务app，名称为当前文件名称</span><br>app = flask.Flask(__name__)<br><br><br><br><span class="hljs-comment">#创建一个访问链接，并将根目录作为访问路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file result&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_db</span>():<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;db result&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_api</span>():<br>    time.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;api result&quot;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-comment">#创建一个访问接口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    result_file = read_file()<br>    result_db = read_db()<br>    result_api = read_api()<br><br>    <span class="hljs-keyword">return</span> json.dumps(&#123;<br>        <span class="hljs-string">&quot;result_file&quot;</span> : read_file(),<br>        <span class="hljs-string">&quot;result_db&quot;</span> : read_db(),<br>        <span class="hljs-string">&quot;result_api&quot;</span> : read_api()<br>    &#125;)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#启动服务app</span><br>    app.run()<br></code></pre></td></tr></table></figure><p>此时在终端输入命令<code>time curl 地址</code>可以查看到CP U耗时约为12秒。</p><p>加入线程池：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> flask<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span>  time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#创建一个服务app，名称为当前文件名称</span><br>app = flask.Flask(__name__)<br><br><span class="hljs-comment">#声明一个全局线程池对象pool</span><br>pool = ThreadPoolExecutor()<br><br><span class="hljs-comment">#创建一个访问链接，并将根目录作为访问路径</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file result&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_db</span>():<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;db result&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_api</span>():<br>    time.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;api result&quot;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-comment">#创建一个访问接口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-comment">#对读取的操作函数用submit方法使用线程池加速，返回future对象类型</span><br>    result_file = pool.submit(read_file)<br>    result_db = pool.submit(read_db)<br>    result_api = pool.submit(read_api)<br><br>    <span class="hljs-keyword">return</span> json.dumps(&#123;<br>        <span class="hljs-string">&quot;result_file&quot;</span> : result_file.result(),<br>        <span class="hljs-string">&quot;result_db&quot;</span> : result_db.result(),<br>        <span class="hljs-string">&quot;result_api&quot;</span> : result_api.result()<br>    &#125;)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#启动服务app</span><br>    app.run()<br></code></pre></td></tr></table></figure><p>此时在终端输入命令<code>time curl 地址</code>可以查看到CP U耗时约为3秒。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><h3 id="1-使用多进程multiprocessing模块加速"><a href="#1-使用多进程multiprocessing模块加速" class="headerlink" title="1.使用多进程multiprocessing模块加速"></a>1.使用多进程multiprocessing模块加速</h3><h4 id="1-1多线程与多进程的对比"><a href="#1-1多线程与多进程的对比" class="headerlink" title="1.1多线程与多进程的对比"></a>1.1多线程与多进程的对比</h4><p>有了多线程threading，为什么还要用多进程multiprocessing?在前面多线程的适用场景中谈到，python程序语言由于GIL的存在，多线程适用于IO密集型的场景，并不适合计算密集性的场景。</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0ywd6r3tj615u0gajsn02.jpg"></p><p>如上图，多个线程在I/O密集型的场景中，Thread 1 运行时遇到I/O操作时，会释放GIL。此时，Thread 2 会获得GIL进入运行。因为这个时候，Thread 2 在运行，同时 Thread 1 在进行I/O操作，所以说在IO密集型的场景中，释放GIL的线程可以利用获得GIL的线程运行时间隙，完成I/O操作，等待下一次获得GIL执行的机会。</p><p>此时的主要任务是I/O，所以多线程的机制可以加速I/O密集型算法。但是对于CPU计算密集型的算法，主要任务是计算，并不是I/O输入输出，多线程则会拖慢运行速度。具体如下图：</p><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0ywo5wx0j615u0a4dgb02.jpg"></p><p>线程的<strong>自动随机切换机制</strong>会耽误CPU的计算时间，成为运行的负担。</p><p>注：multiprocessing模块正是Python为了解决GIL缺陷而引入放入一个模块，原理是利用<strong>多进程</strong>在多CPU上同时并行执行。</p><h4 id="1-2多线程与多进程的知识梳理"><a href="#1-2多线程与多进程的知识梳理" class="headerlink" title="1.2多线程与多进程的知识梳理"></a>1.2多线程与多进程的知识梳理</h4><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0ywzacn1j61rq0u00z402.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#引入模块</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-comment">#新建进程</span><br>p = Process(target=func,args=(<span class="hljs-string">&#x27;bob&#x27;</span>,))<br><br><span class="hljs-comment">#启动进程</span><br>p.start()<br><br><span class="hljs-comment">#等待结束进程</span><br>p.join()<br><br><span class="hljs-comment">#数据通信</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Queue<br>q = Queue()<br>q.put([<span class="hljs-number">42</span>,<span class="hljs-literal">None</span>,<span class="hljs-string">&#x27;hi&#x27;</span>])<br>item = q.get()<br><br><span class="hljs-comment">#进程安全锁:访问共享资源时，加入锁</span><br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Lock<br>lock = Lock()<br><span class="hljs-keyword">with</span> lock:<br>  <span class="hljs-comment">#do something</span><br>  <br><span class="hljs-comment">#池化技术</span><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor<br><span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> executor:<br>  <span class="hljs-comment">#方法1</span><br>  results = executor.<span class="hljs-built_in">map</span>(func,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>  <br>  <span class="hljs-comment">#方法2</span><br>  future = executor.submit(func,<span class="hljs-number">1</span>)<br>  result = future.result()<br></code></pre></td></tr></table></figure><h4 id="1-3实战案例：单线程、多线程、多进程基于CPU密集计算的加速对比"><a href="#1-3实战案例：单线程、多线程、多进程基于CPU密集计算的加速对比" class="headerlink" title="1.3实战案例：单线程、多线程、多进程基于CPU密集计算的加速对比"></a>1.3实战案例：单线程、多线程、多进程基于CPU密集计算的加速对比</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> *<br><br>PRIMES = [ <span class="hljs-number">112272535095293</span> ] * <span class="hljs-number">100</span><br><span class="hljs-comment">#判断number是否为素数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">number</span>):<br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    sqrt_number = <span class="hljs-built_in">int</span>(math.floor(math.sqrt(number)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,sqrt_number+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">if</span> number % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">single_thread</span>():<br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> PRIMES:<br>        is_prime(number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_thread</span>():<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>        pool.<span class="hljs-built_in">map</span>(is_prime,PRIMES)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_process</span>():<br>    <span class="hljs-keyword">with</span> ProcessPoolExecutor() <span class="hljs-keyword">as</span> pool:<br>        pool.<span class="hljs-built_in">map</span>(is_prime,PRIMES)<br><br><span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    start  = time.time()<br>    single_thread()<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;single_thread cost&quot;</span>,end-start,<span class="hljs-string">&quot;seconds&quot;</span>)<br><br>    start  = time.time()<br>    multi_thread()<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;multi_thread cost&quot;</span>,end-start,<span class="hljs-string">&quot;seconds&quot;</span>)<br><br>    start  = time.time()<br>    multi_process()<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;multi_process cost&quot;</span>,end-start,<span class="hljs-string">&quot;seconds&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yx8kcp9j61ii0toq6102.jpg"></p><h3 id="2-基于Flask框架的Web服务器加速"><a href="#2-基于Flask框架的Web服务器加速" class="headerlink" title="2.基于Flask框架的Web服务器加速"></a>2.基于Flask框架的Web服务器加速</h3><p>在大部分情况下，Web服务器的请求都是IO密集型的，即我们用多线程加速即可解决问题。极少数是计算密集型的服务请求，这里我们举出一个计算密集型的例子，意在示范基于Flask框架的Web服务器使用多进程multiprocessing模块加速。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> flask<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ProcessPoolExecutor<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> json<br><br><br>app = flask.Flask(__name__)<br><br><span class="hljs-comment">#判断number是否为素数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_prime</span>(<span class="hljs-params">number</span>):<br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    sqrt_number = <span class="hljs-built_in">int</span>(math.floor(math.sqrt(number)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,sqrt_number+<span class="hljs-number">1</span>,<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">if</span> number % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/is_prime/&lt;numbers&gt;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">api_is_prime</span>(<span class="hljs-params">numbers</span>):<br>    number_list = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> numbers.split(<span class="hljs-string">&quot;,&quot;</span>)]<br>    results = process_pool.<span class="hljs-built_in">map</span>(is_prime,number_list)<br><br>    <span class="hljs-keyword">return</span> json.dumps(<span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(number_list,results)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    process_pool = ProcessPoolExecutor()<br>    app.run()<br></code></pre></td></tr></table></figure><p>注：多进程必须要有<code>if __name__ == &quot;__main__&quot;:</code>，并且进程池对象的声明创建<code>process_pool = ProcessPoolExecutor()</code>要在<code>if __name__ == &quot;__main__&quot;:</code>里面。关于Flask框架的应用，知识难度不大，可自行学习。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="1-异步IO实现并发爬虫"><a href="#1-异步IO实现并发爬虫" class="headerlink" title="1.异步IO实现并发爬虫"></a>1.异步IO实现并发爬虫</h3><h4 id="1-1单线程爬虫的执行路径"><a href="#1-1单线程爬虫的执行路径" class="headerlink" title="1.1单线程爬虫的执行路径"></a>1.1单线程爬虫的执行路径</h4><p><img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yxhd124j61r20gqq5m02.jpg"></p><p>对于单线程的爬虫，单线依次串行执行爬取URL的过程。在每个爬取URL过程中，具体细节如下：</p><ol><li>启动程序，CPU计算，分配资源；</li><li>等待IO从网页上读取网页内容；</li><li>CPU后续处理计算读取的网页内容。</li></ol><p>我们可以看出，在每个URL爬取中，等待IO是，第3步的CPU是处于空闲等待状态的。同时，后面的URL的爬取中的第1步的CPU也是处于空闲等待上一个URL爬取结束。这样一来，时间将会被耽误，速度性能下降。</p><h4 id="1-2使用协程在单线程中实现并发"><a href="#1-2使用协程在单线程中实现并发" class="headerlink" title="1.2使用协程在单线程中实现并发"></a>1.2使用协程在单线程中实现并发</h4><p>在上述单线程串行爬取URL中，我们发现了降低爬取速度的原因。这里，我们可以使用协程在单线程中实现并发，加速爬取速度。</p><p>原理：</p><ul><li><p>用一个超级循环（实质上是while True）循环</p></li><li><p>配合IO多路复用原理（即在IO时，CPU可以做其他事情）</p><p>​                                         URL1                      URL2                           URL3<img src="Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/008i3skNly1gv0yxnq4pgj61as0f8jsu02.jpg"></p></li></ul><p>如上图，在执行爬虫时，在每个URL的爬取中，执行第1步后，在执行第2步等待IO读取时，执行利用等待IO读取的时间，继续爬取下一个URL。以此类推，当所有的URL读取完毕后，再一次执行每个URL爬取的第3步CPU，这样节省了每个IO等待空闲的时间，可以提升爬取速度，上述过程即协程实现单线程的并发。</p><h4 id="1-3异步IO库：asyncio"><a href="#1-3异步IO库：asyncio" class="headerlink" title="1.3异步IO库：asyncio"></a>1.3异步IO库：asyncio</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入异步IO库</span><br><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-comment">#获取事件循环，创建事件循环对象</span><br>loop = asyncio.get_event_loop()<br><br><span class="hljs-comment">#定义协程</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">url</span>):<br>  <span class="hljs-keyword">await</span> get_url(url)<span class="hljs-comment">#await是在等待IO时是不进行阻塞，而是进入下一个程序的处理，即进入下一个URL的爬取</span><br>  <br><span class="hljs-comment">#创建task列表</span><br>tasks = [ loop.create_task(myfunc(url)) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls ]<br><br><span class="hljs-comment">#执行爬虫事件列表</span><br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure><p>注：要用在异步编程中，依赖的库必须支持异步IO特性，即类似于上述爬取URL的过程。而在爬虫中的requests库不支持异步IO特性，需要用aiohttp库实现。</p><h4 id="1-4案例实战"><a href="#1-4案例实战" class="headerlink" title="1.4案例实战"></a>1.4案例实战</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#文件名：BlogRequest</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><br>url_list = [<br>    <span class="hljs-string">f&quot;https://www.cnblogs.com/cate/python/<span class="hljs-subst">&#123;page&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>)<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15&quot;</span><br>    &#125;<br>    html = requests.get(url=url,headers=headers).text<br>    <span class="hljs-keyword">return</span> html<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">html</span>):<br>    tree = etree.HTML(html)<br>    article_list = tree.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;post_list&quot;]/article&#x27;</span>)<br>    <span class="hljs-comment"># href_list = []</span><br>    <span class="hljs-comment"># title_list = []</span><br>    <span class="hljs-comment"># for art_li in article_list:</span><br>        <span class="hljs-comment"># href_list.append(art_li.xpath(&#x27;.//div/a/@href&#x27;)[0])</span><br>        <span class="hljs-comment"># title_list.append(art_li.xpath(&#x27;.//div/a/text()&#x27;)[0])</span><br>    <span class="hljs-keyword">return</span> [(art_li.xpath(<span class="hljs-string">&#x27;.//div/a/@href&#x27;</span>)[<span class="hljs-number">0</span>],art_li.xpath(<span class="hljs-string">&#x27;.//div/a/text()&#x27;</span>)[<span class="hljs-number">0</span>])<span class="hljs-keyword">for</span> art_li <span class="hljs-keyword">in</span> article_list]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> BlogRequest<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_request</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取地址：&quot;</span>,url)<br>    <span class="hljs-keyword">async</span>  <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:<br>            result = <span class="hljs-keyword">await</span> response.text()          <span class="hljs-comment">#加入await，进行IO等待，进入下一个地址的爬取</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;爬取地址：<span class="hljs-subst">&#123;url&#125;</span>,<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(result)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#创建事件循环</span><br>loop = asyncio.get_event_loop()<br><br><span class="hljs-comment">#创建tasks列表</span><br>tasks = [<br>    <span class="hljs-comment">#请求函数的异步执行任务放在事件循环对象中</span><br>    loop.create_task(async_request(url))<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> BlogRequest.url_list<br>]<br><br>start = time.time()<br><span class="hljs-comment">#在事件循环中，等待tasks全部执行完毕</span><br>loop.run_until_complete(asyncio.wait(tasks))<br>end = time.time()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;use time seconds:&quot;</span>,end-start)<br></code></pre></td></tr></table></figure><p>注：use time seconds: 0.5591192245483398</p><p>在之前的单线程与多线程的实验中：</p><p>​        single_threading: 14.630054950714111 second</p><p>​        multi_threading: 0.9659450054168701 second</p><p>可以看出：单线程异步协程的速度最多，多线程在线程的切换时需要额外的时间开销，单线程异步协程没有线程的切换，仅一个线程内部IO操作的超级循环处理。</p><h3 id="2-信号量在异步IO爬虫中的应用"><a href="#2-信号量在异步IO爬虫中的应用" class="headerlink" title="2.信号量在异步IO爬虫中的应用"></a>2.信号量在异步IO爬虫中的应用</h3><h4 id="2-1信号量简介"><a href="#2-1信号量简介" class="headerlink" title="2.1信号量简介"></a>2.1信号量简介</h4><p>信号量，Semaphore，又称为信号量、旗语。它可以控制异步IO的并发度，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。</p><ul><li>当线程完成一次对该semaphore对象的等待（wait）时，该计数值减1；</li><li>当线程完成一次对该semaphore对象的释放（release）时，计数值加1。</li><li>当计数值为0时，则线程会等待该semaphore对象而不再能成功，直至该semaphore对象变成signaled状态。</li><li>当semaphore对象的计数值大于0时，为signaled状态；当semaphore对象的计数值等于0时，为nosignaled状态。</li></ul><h4 id="2-2使用方式"><a href="#2-2使用方式" class="headerlink" title="2.2使用方式"></a>2.2使用方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用方式1</span><br>sem = asyncio.Semaphore(<span class="hljs-number">10</span>) <span class="hljs-comment">#并发度为10</span><br><br><span class="hljs-comment">#...later</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>  <span class="hljs-comment">#work with shared resource #此时，此处的代码并发度为10以内</span><br>  <br>  <br>  <br><span class="hljs-comment">#使用方法2</span><br>sem = asyncio.Semaphore(<span class="hljs-number">10</span>)<span class="hljs-comment">#并发度为10</span><br><br><span class="hljs-comment">#...later</span><br><span class="hljs-keyword">await</span> sem.acquire()<br><span class="hljs-keyword">try</span>:<br>  <span class="hljs-comment">#work with shared resource #此时，此处的代码并发度为10以内</span><br><span class="hljs-keyword">finally</span>:<br>  sem.release()<br></code></pre></td></tr></table></figure><h4 id="2-3代码演示"><a href="#2-3代码演示" class="headerlink" title="2.3代码演示"></a>2.3代码演示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> BlogRequest<br><br><span class="hljs-comment">#声明并发度</span><br>sem = asyncio.Semaphore(<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">async_request</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> sem:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取地址：&quot;</span>,url)<br>        <span class="hljs-keyword">async</span>  <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>            <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:<br>                result = <span class="hljs-keyword">await</span> response.text()          <span class="hljs-comment">#加入await，进行IO等待，进入下一个地址的爬取</span><br>                <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;爬取地址：<span class="hljs-subst">&#123;url&#125;</span>,<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(result)&#125;</span>&quot;</span>)<br><br><span class="hljs-comment">#创建事件循环</span><br>loop = asyncio.get_event_loop()<br><br><span class="hljs-comment">#创建tasks列表</span><br>tasks = [<br>    <span class="hljs-comment">#请求函数的异步执行任务放在事件循环对象中</span><br>    loop.create_task(async_request(url))<br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> BlogRequest.url_list<br>]<br><br>start = time.time()<br><span class="hljs-comment">#在事件循环中，等待tasks全部执行完毕</span><br>loop.run_until_complete(asyncio.wait(tasks))<br>end = time.time()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;use time seconds:&quot;</span>,end-start)<br></code></pre></td></tr></table></figure><p>加入信号量是为了控制并发度，是对访问服务器的保护，防止并发度过高导致访问的服务器崩溃。</p><h2 id="subprocess启动电脑程序"><a href="#subprocess启动电脑程序" class="headerlink" title="subprocess启动电脑程序"></a>subprocess启动电脑程序</h2><h3 id="1-使用subprocess启动电脑的子进程"><a href="#1-使用subprocess启动电脑的子进程" class="headerlink" title="1.使用subprocess启动电脑的子进程"></a>1.使用subprocess启动电脑的子进程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">subprocess模块：<br><span class="hljs-number">1.</span>可以生成新的进程<br><span class="hljs-number">2.</span>可以连接它们的输入、输出以及错误输出管道<br><span class="hljs-number">3.</span>获取进程的返回码<br><br>应用场景：<br><span class="hljs-number">1.</span>定时打开酷狗音乐播放器<br><span class="hljs-number">2.</span>调用7z.exe自动解压文件<br><span class="hljs-number">3.</span>通过Python远程提交一个torrent种子文件，用电脑启动下载<br></code></pre></td></tr></table></figure><h3 id="2-subprocess实例"><a href="#2-subprocess实例" class="headerlink" title="2.subprocess实例"></a>2.subprocess实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.用默认的应用程序打开歌曲文件</span><br><span class="hljs-comment">#注：windows下是start、mac是open、Linux是see</span><br><span class="hljs-comment">#windows环境需要加shell=True</span><br>proc = subprocess.Popen([<span class="hljs-string">&#x27;open&#x27;</span>,<span class="hljs-string">&#x27;广寒谣dj.mp3&#x27;</span>])<br>proc.communicate()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#2.用7z.exe解压7z文件</span><br>proc = subprocess.Popen([<span class="hljs-string">r&quot;C:\Program Files\7-Zip\7z.exe&quot;</span>,<span class="hljs-comment">#程序地址</span><br>                        <span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-comment">#解压</span><br>                         <span class="hljs-string">&quot;./datas/7z_test.7z&quot;</span>,<span class="hljs-comment">#待解压文件地址</span><br>                         <span class="hljs-string">&quot;-o./datas/extract_7z_test&quot;</span>,<span class="hljs-comment">#解压至</span><br>                         <span class="hljs-string">&quot;-aoa&quot;</span><br>                        ])<br>proc.communicate()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程与进程</tag>
      
      <tag>并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora教程【已完结】</title>
    <link href="/2021/01/02/Typora%E6%95%99%E7%A8%8B/"/>
    <url>/2021/01/02/Typora%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。</p><span id="more"></span><h4 id="Typora教程"><a href="#Typora教程" class="headerlink" title="Typora教程"></a>Typora教程</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><p>文档后缀为.md和.markdown</p><h5 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h5><ul><li>加粗： <code>Ctrl + B</code></li><li>标题： <code>Ctrl + H</code></li><li>插入链接： <code>Ctrl + K</code></li><li>行内代码： <code>Ctrl + Shift + K</code></li><li>插入图片： <code>Ctrl + Shift + I</code></li><li>撤销： <code>Ctrl + Z</code></li><li>下划线：<code>Ctrl + U</code></li><li>一级标题： <code>Ctrl + 1</code> – 以此类推</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Ctrl<span class="hljs-string">+1</span>  一阶标题    Ctrl+B  字体加粗<br>Ctrl<span class="hljs-string">+2</span>  二阶标题    Ctrl+I  字体倾斜<br>Ctrl<span class="hljs-string">+3</span>  三阶标题    Ctrl+U  下划线<br>Ctrl<span class="hljs-string">+4</span>  四阶标题    Ctrl+Home   返回Typora顶部<br>Ctrl<span class="hljs-string">+5</span>  五阶标题    Ctrl+End    返回Typora底部<br>Ctrl<span class="hljs-string">+6</span>  六阶标题    Ctrl+T  创建表格<br>Ctrl+L  选中某句话   Ctrl+K  创建超链接<br>Ctrl+D  选中某个单词  Ctrl+F  搜索<br>Ctrl+E  选中相同格式的文字   Ctrl+H  搜索并替换<br>Alt+Shift<span class="hljs-string">+5</span> 删除线 Ctrl+Shift+I    插入图片<br>Ctrl+Shift+M    公式块 Ctrl+Shift+Q    引用<br><br>注：一些实体符号需要在实体符号之前加”\”才能够显示<br></code></pre></td></tr></table></figure><h5 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h5><p>&gt; + 空格 + 引用文字</p><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>使用 * + - 都可以创建一个无序列表</p><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>使用 1. 2. 3. 创建有序列表</p><h5 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h5><p>\ -[ ] 不勾选</p><p>\ -[x] 勾选</p><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><p>在Typora中插入程序代码的方式有两种：使用反引号 `（~ 键）、使用缩进（Tab）。</p><ul><li><p>插入行内代码，即插入一个单词或者一句代码的情况，使用 <code>code</code> 这样的形式插入。</p></li><li><p>插入多行代码输入3个反引号（`） + 回车，并在后面选择一个语言名称即可实现语法高亮。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">helloworld</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello, world!&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h5 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h5><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。</p><p>按下 <code>$$</code>，然后按下回车键，即可进行数学公式的编辑。<br>$$<br>\mathbf{V}_1\times\mathbf{V}_2 = \mathbf{X}_3<br>$$</p><h5 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h5><p>输入 <code>| 表头1 | 表头2 |</code>并回车。即可创建一个包含2列表。快捷键 <code>Ctrl + T</code>弹出对话框。</p><table><thead><tr><th>学号</th><th>姓名</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><ul><li>不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行</li><li>列与列之间用管道符号<code>|</code> 隔开</li><li>还可设置对齐方式(表头与内容之间)，如果不使用对齐标记，内容默认左对齐，表头居中对齐<ul><li>左对齐 ：|</li><li>右对齐 |：</li><li>中对齐 ：|：</li></ul></li><li>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界</li><li>为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）</li></ul><h5 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h5><p>这是脚注[^1]</p><p>[^1]</p><h5 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h5><p>输入 <code>***</code> 或者 <code>---</code> 再按回车即可绘制一条水平线，如下：</p><hr><h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><p>输入 <code>[ toc ]</code> 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><p>[toc]</p><h5 id="跨度元素"><a href="#跨度元素" class="headerlink" title="跨度元素"></a>跨度元素</h5><p>跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。</p><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><h6 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h6><p>这是一个带有标题属性的 <code>[链接](http://example.com/ &quot;标题&quot;)</code><br>这是一个没有标题属性的 <code>[链接](http://example.net/)</code></p><h6 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h6><p>Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。</p><p>Typora还会自动链接标准网址。</p><p><a href="http://www.baidu.com/">www.baidu.com</a></p><h6 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h6><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[显示的文字]</span>(<span class="hljs-attribute">C</span>:\Users\Hider\Desktop\echart.png <span class="hljs-string">&quot;图片标题&quot;</span>)<br>!<span class="hljs-selector-attr">[显示的文字]</span>(<span class="hljs-attribute">C</span>:\Users\Hider\Desktop\echart.png)<br></code></pre></td></tr></table></figure><p>除了以上2种方式之外，还可以直接将图片拖拽进来，自动生成链接。</p><h5 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h5><p>可以使用<code>&lt;sup&gt;文本&lt;/sup&gt;</code>实现上标，可以使用 <code>&lt;sub&gt;文本&lt;/sub&gt;</code>实现下标。(需在设置中打开该功能)</p><p>X<sub>2</sub>   H<sup>2</sup>O</p><h5 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h5><p><code>==高亮==</code>(需在设置中打开该功能)</p><p>==哈哈哈==</p><h5 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h5><p>使用 <code>&lt;center&gt;这是要居中的内容&lt;/center&gt;</code>可以使文本居中</p><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><p>使用<code>~~删除线~~</code> 快捷键 <code>Alt + Shift + 5</code></p><p><del>删除线</del></p><h5 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h5><p>使用 <code>空格 + 空格 + Enter</code>可以实现换行，例如：</p><p>或者可以使用<code>&lt;br/&gt;</code>实现换行。</p><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*</span>   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br><span class="hljs-section">#   井字号</span><br><span class="hljs-bullet">+</span>   加号<br><span class="hljs-bullet">-</span>   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑 <kbd> </kbd> – 白色框框</p><h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><p>参考链接：<a href="https://www.cnblogs.com/hider/p/11614688.html#fnref1">Typora入门</a></p>]]></content>
    
    
    <categories>
      
      <category>工具软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typora</tag>
      
      <tag>工具教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构【更新中】</title>
    <link href="/2020/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>数据结构是一门计算机专业基础必修课，它是数据组织的重要工具。</p><span id="more"></span><p>视频课：<a href="https://www.bilibili.com/video/BV1sy4y1q79M?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1sy4y1q79M?spm_id_from=333.999.0.0</a></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>时间复杂度 &gt; 空间复杂度</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在<strong>连续</strong>的内存空间中，存储一组<strong>相同类型</strong>的元素</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>元素与索引：值与下标</p><p>访问与搜索：通过索引访问值；直接找值</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>访问：通过索引访问值，O(1)</p><p>搜索：O(N)</p><p>插入：O(N)</p><p>删除：O(N)</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>适合读，不适合写：读多写少</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1.创建数组"></a>1.创建数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a = []<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>System.out.println(a);<br><br><span class="hljs-type">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>System.out.println(b);<br><br><span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; a.length;i++)&#123;<br>    c[i] = i+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//import ArrayList</span><br>ArrayList&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayLiat</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)&#123;<br>    arr.add(i+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2.添加元素"></a>2.添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#O(1)</span><br>a.append(<span class="hljs-number">1</span>)<br>a.append(<span class="hljs-number">2</span>)<br>a.append(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#O(N)</span><br>a.insert(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>)<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">99</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认插在尾部</span><br>arr.add(<span class="hljs-number">99</span>);<br><span class="hljs-comment">//[1,2,3,99]</span><br>arr.add(<span class="hljs-number">3</span>,<span class="hljs-number">88</span>);<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">88</span>,<span class="hljs-number">99</span>]<br></code></pre></td></tr></table></figure><h4 id="3-访问元素"><a href="#3-访问元素" class="headerlink" title="3.访问元素"></a>3.访问元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">t = a[<span class="hljs-number">2</span>]<br><span class="hljs-comment">#t = 99</span><br><br><span class="hljs-built_in">int</span> c1 = c[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">int</span> arr1 = arr.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="4-更新元素"><a href="#4-更新元素" class="headerlink" title="4.更新元素"></a>4.更新元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a[<span class="hljs-number">2</span>] = <span class="hljs-number">88</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">c[<span class="hljs-number">1</span>] = <span class="hljs-number">11</span>;<br>arr.set(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>);<br></code></pre></td></tr></table></figure><h4 id="5-删除元素"><a href="#5-删除元素" class="headerlink" title="5.删除元素"></a>5.删除元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#[1,2,88,3]</span><br><span class="hljs-comment">#删除值O(N)</span><br>a.remove(<span class="hljs-number">88</span>)<br><span class="hljs-comment">#[1,2,3]</span><br><br><span class="hljs-comment">#通过索引删除</span><br>a.pop(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#[1,3]</span><br><br><span class="hljs-comment">#删除尾部</span><br>a.pop()<br><span class="hljs-comment">#[1]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除元素值</span><br>arr.remove(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="6-获取数组长度-O-1"><a href="#6-获取数组长度-O-1" class="headerlink" title="6.获取数组长度:O(1)"></a>6.获取数组长度:O(1)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>size = <span class="hljs-built_in">len</span>(a)<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int cSize <span class="hljs-operator">=</span> c.length<span class="hljs-comment">;</span><br>int aeeSize <span class="hljs-operator">=</span> arr.size()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="7-遍历数组"><a href="#7-遍历数组" class="headerlink" title="7.遍历数组"></a>7.遍历数组</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-selector-tag">a</span>:<br><span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-keyword">for</span> index,elemnt <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br><span class="hljs-built_in">print</span>(index,element)<br><br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(a)):<br><span class="hljs-built_in">print</span>(<span class="hljs-selector-tag">i</span>,<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; c.length; i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> c[i];<br>    System.out.println(t);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.size(); i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr.get(i);<br>    System.out.println(t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-查找某个元素"><a href="#8-查找某个元素" class="headerlink" title="8.查找某个元素"></a>8.查找某个元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#根据元素值返回值的索引 O(N)</span><br>index = a.index(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#返回：index = 1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; c.length; i++)&#123;<br>    <span class="hljs-keyword">if</span> (c[i]==<span class="hljs-number">99</span>)&#123;<br>        System.out.println(c[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">is99</span> <span class="hljs-operator">=</span> arr.contains(<span class="hljs-number">99</span>);<br>System.out.println(is99);<br></code></pre></td></tr></table></figure><h4 id="9-数组排序"><a href="#9-数组排序" class="headerlink" title="9.数组排序"></a>9.数组排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#O(NlogN)</span><br>a = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>a.sort()<br><span class="hljs-comment">#[1,2,3]</span><br>a.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#[3,2,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;;<br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>arr.add(<span class="hljs-number">2</span>);<br>arr.add(<span class="hljs-number">3</span>);<br>arr.add(<span class="hljs-number">1</span>);<br><br>Arrays.sort(c);<br>Collections.sort(arr);<br>Collections.sort(arr,Collections.reverseOrder());<br></code></pre></td></tr></table></figure><h2 id="链表（单向链表）"><a href="#链表（单向链表）" class="headerlink" title="链表（单向链表）"></a>链表（单向链表）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>访问：O(N)</p><p>搜索：O(N)</p><p>插入：O(1)</p><p>删除：O(1)</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>与数组相反，读得慢，写得快。适合读少写多的场景</p><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-创建链表"><a href="#1-创建链表" class="headerlink" title="1.创建链表"></a>1.创建链表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">linkedlist = deque()<br><span class="hljs-comment">#deque也是队列</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="2-添加元素-1"><a href="#2-添加元素-1" class="headerlink" title="2.添加元素"></a>2.添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">linkedlist.append(<span class="hljs-number">1</span>)<br>linkedlist.append(<span class="hljs-number">2</span>)<br>linkedlist.append(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#[1,2,3]</span><br><br>linkedlist.insert(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>)<br><span class="hljs-comment">#[1,2,99,3]   O(N)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>System.out.println(list.toString());<br><span class="hljs-comment">//[1,2,3]</span><br><br>list.add(<span class="hljs-number">2</span>,<span class="hljs-number">99</span>);<br><span class="hljs-comment">//[1,2,99,3]</span><br></code></pre></td></tr></table></figure><h4 id="3-访问元素-1"><a href="#3-访问元素-1" class="headerlink" title="3.访问元素"></a>3.访问元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">element = linkedlist[<span class="hljs-number">2</span>]<br><span class="hljs-comment">#99</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//99</span><br></code></pre></td></tr></table></figure><h4 id="4-搜素元素"><a href="#4-搜素元素" class="headerlink" title="4.搜素元素"></a>4.搜素元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">index = linkedlist.index(<span class="hljs-number">99</span>)<br><span class="hljs-comment">#2</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> list.indexOf(<span class="hljs-number">99</span>);<br><span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h4 id="5-更新元素"><a href="#5-更新元素" class="headerlink" title="5.更新元素"></a>5.更新元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">linkedlist[<span class="hljs-number">2</span>] = <span class="hljs-number">88</span><br><span class="hljs-comment">#[1,2,88,3] O(N)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">list.set(<span class="hljs-number">2</span>,<span class="hljs-number">88</span>);<br><span class="hljs-comment">//[1,2,88,3]</span><br></code></pre></td></tr></table></figure><h4 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">linkedlist.remove(<span class="hljs-number">88</span>)<br><span class="hljs-comment">#等同于del linkedliat[2]</span><br><span class="hljs-comment">#[1,2,3] O(N)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">list.remove(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//[1,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="7-长度"><a href="#7-长度" class="headerlink" title="7.长度"></a>7.长度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">length = <span class="hljs-built_in">len</span>(linkedlist)<br><span class="hljs-comment">#3</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> list.size();<br><span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h4 id="8-反转链表"><a href="#8-反转链表" class="headerlink" title="8.反转链表"></a>8.反转链表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:<br>    prev = ListNode()<br>    prev = <span class="hljs-literal">None</span><br>    curr = head<br>    <span class="hljs-keyword">while</span> curr:<br>        t = curr.<span class="hljs-built_in">next</span><br>        curr.<span class="hljs-built_in">next</span> = prev<br>        prev = curr<br>        curr = t<br>    <span class="hljs-keyword">return</span> prev<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:<br>    dummy = ListNode(<span class="hljs-number">0</span>)<br>    dummy.<span class="hljs-built_in">next</span> = head<br>    <span class="hljs-keyword">while</span> head <span class="hljs-keyword">and</span> head.<span class="hljs-built_in">next</span>:<br>        dnext = dummy.<span class="hljs-built_in">next</span><br>        hnext = head.<span class="hljs-built_in">next</span><br>        dummy.<span class="hljs-built_in">next</span> = hnext<br>        head.<span class="hljs-built_in">next</span> = hnext.<span class="hljs-built_in">next</span><br>        hnext.<span class="hljs-built_in">next</span> = dnext<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="队列（单端队列）"><a href="#队列（单端队列）" class="headerlink" title="队列（单端队列）"></a>队列（单端队列）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>先进先出，FIFO</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>单端队列：数据元素只能从队尾进，队首出</p><p>双端队列：分为左端和右端，可以理解为两个队首和队尾相反的单端队列合并而成的队列</p><h3 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-创建队列"><a href="#1-创建队列" class="headerlink" title="1.创建队列"></a>1.创建队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建队列</span><br>queue = deque()<br><br><span class="hljs-comment">#deque()是双端队列，但是我们只需要用其单端队列功能即可</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建队列</span><br>Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="2-添加元素-2"><a href="#2-添加元素-2" class="headerlink" title="2.添加元素"></a>2.添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#添加元素</span><br>queue.append(<span class="hljs-number">1</span>)<br>queue.append(<span class="hljs-number">2</span>)<br>queue.append(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#[1,2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加元素</span><br>queue.add(<span class="hljs-number">1</span>);<br>queue.add(<span class="hljs-number">2</span>);<br>queue.add(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//[1,2,3]</span><br><span class="hljs-comment">//System.out.println(queue.toString());</span><br></code></pre></td></tr></table></figure><h4 id="3-获取即将出队的元素"><a href="#3-获取即将出队的元素" class="headerlink" title="3.获取即将出队的元素"></a>3.获取即将出队的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取队首元素</span><br>queue_head = queue[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取队首元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">queue_head</span> <span class="hljs-operator">=</span> queue.peek();<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//System.out.println(queue_head);</span><br></code></pre></td></tr></table></figure><h4 id="4-删除即将出队的元素"><a href="#4-删除即将出队的元素" class="headerlink" title="4.删除即将出队的元素"></a>4.删除即将出队的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#删除队首元素</span><br>pop_head = queue.popleft()<br><span class="hljs-comment"># 1</span><br><br><span class="hljs-comment">#删除队尾元素</span><br>pop_tail = queue.popright()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除队首元素</span><br>queue_head = queue.poll();<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//System.out.println(queue.toString());</span><br><span class="hljs-comment">//[2,3]</span><br></code></pre></td></tr></table></figure><h4 id="5-判断空"><a href="#5-判断空" class="headerlink" title="5.判断空"></a>5.判断空</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取队列长度</span><br><span class="hljs-built_in">len</span>(queue) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断空队列</span><br>System.out.println(queue.isEmpty());<br><span class="hljs-comment">//true  false</span><br></code></pre></td></tr></table></figure><h4 id="6-队列长度"><a href="#6-队列长度" class="headerlink" title="6.队列长度"></a>6.队列长度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取队列长度</span><br><span class="hljs-built_in">len</span>(queue)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取队列长度</span><br>queue.size()<br></code></pre></td></tr></table></figure><h4 id="7-遍历队列"><a href="#7-遍历队列" class="headerlink" title="7.遍历队列"></a>7.遍历队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>  temp = queue.popleft()<br>  <span class="hljs-built_in">print</span>(temp)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">queue_head</span> <span class="hljs-operator">=</span> queue.poll();<br>  System.out.println(queue_head);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>先进后出</p><h3 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-创建栈"><a href="#1-创建栈" class="headerlink" title="1.创建栈"></a>1.创建栈</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建栈</span><br>stack = []<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建栈</span><br>Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="2-添加元素-3"><a href="#2-添加元素-3" class="headerlink" title="2.添加元素"></a>2.添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#添加元素</span><br>stack.append(<span class="hljs-number">1</span>)<br>stack.append(<span class="hljs-number">2</span>)<br>stack.append(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#[1,2,3]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加元素</span><br>stack.push(<span class="hljs-number">1</span>);<br>stack.push(<span class="hljs-number">2</span>);<br>stack.push(<span class="hljs-number">3</span>);<br>System.out.println(stack.toString());<br></code></pre></td></tr></table></figure><h4 id="3-查看栈顶元素"><a href="#3-查看栈顶元素" class="headerlink" title="3.查看栈顶元素"></a>3.查看栈顶元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#查看栈顶元素</span><br>stack[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取栈顶元素</span><br>stack.peek();<br></code></pre></td></tr></table></figure><h4 id="4-删除栈顶元素"><a href="#4-删除栈顶元素" class="headerlink" title="4.删除栈顶元素"></a>4.删除栈顶元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#删除栈顶元素</span><br>temp = stack.pop()<br><span class="hljs-comment">#3</span><br><span class="hljs-comment">#python中的 pop()函数默认删除最后一个元素，并返回删除元素的值</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除栈顶元素</span><br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> stack.pop();<br></code></pre></td></tr></table></figure><h4 id="5-栈的长度"><a href="#5-栈的长度" class="headerlink" title="5.栈的长度"></a>5.栈的长度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#栈的长度</span><br><span class="hljs-built_in">len</span>(stack)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//栈的长度</span><br>stack.size();<br></code></pre></td></tr></table></figure><h4 id="6-判断栈空"><a href="#6-判断栈空" class="headerlink" title="6.判断栈空"></a>6.判断栈空</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#判断栈是否为空</span><br><span class="hljs-built_in">len</span>(stack)==<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断栈是否为空</span><br>stack.isEmpty();<br></code></pre></td></tr></table></figure><h4 id="7-遍历栈"><a href="#7-遍历栈" class="headerlink" title="7.遍历栈"></a>7.遍历栈</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历栈</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack)&gt;<span class="hljs-number">0</span>:<br>  temp = stack.pop()<br>  <span class="hljs-built_in">print</span>(temp)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历栈</span><br><span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> stack.pop();<br>  System.out.println(temp);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>又称散列表，由若干个键值对组成的数据结构。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>通过索引以O(1)的快速方式完成查询。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>两个不同的key定位到同一个内存地址，将该地址的内容修改为链表的数据结构形式存储。</p><h3 id="常用操作-4"><a href="#常用操作-4" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-创建哈希表"><a href="#1-创建哈希表" class="headerlink" title="1.创建哈希表"></a>1.创建哈希表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用列表数组的方式表示哈希关系</span><br>hashTable = [<span class="hljs-string">&#x27;&#x27;</span>]*<span class="hljs-number">4</span>   <span class="hljs-comment">#4个空元素的数组</span><br><br><span class="hljs-comment">#使用字典的方式创建哈希表</span><br>mapping = &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建哈希表</span><br>String[] hashTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">4</span>];  <span class="hljs-comment">//数组的方式</span><br><br>HashMap&lt;Integer,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <span class="hljs-comment">//哈希表的方式</span><br></code></pre></td></tr></table></figure><h4 id="2-添加元素-4"><a href="#2-添加元素-4" class="headerlink" title="2.添加元素"></a>2.添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#添加元素(0的位置可定义，可不定义)</span><br>hashTable[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;LiMei&quot;</span><br>hashTable[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;HanLei&quot;</span><br>hashTable[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;GuJun&quot;</span><br><br><span class="hljs-comment">#添加元素</span><br>mapping[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;LiMei&quot;</span><br>mapping[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;HanLei&quot;</span><br>mapping[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;GuJun&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加元素(0的位置可定义，可不定义)</span><br>hashTable[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;LiMei&quot;</span>;<br>hashTable[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;HanLei&quot;</span>;<br>hashTable[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;GuJun&quot;</span>;<br>  <br>map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;LiMei&quot;</span>);<br>map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;HanLei&quot;</span>);<br>map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;GuJun&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#删除元素</span><br>hashTable[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;&#x27;</span><br>mapping.pop(<span class="hljs-number">1</span>)   <span class="hljs-comment">#或者 del mapping[1]</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除元素</span><br>hashTable[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>map.remove(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="4-修改元素"><a href="#4-修改元素" class="headerlink" title="4.修改元素"></a>4.修改元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#修改元素</span><br>hashTable[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Lele&quot;</span><br>mapping[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Lele&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改元素</span><br>hashTable[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;bishi&quot;</span>;<br>map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;bishi&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="5-获取元素"><a href="#5-获取元素" class="headerlink" title="5.获取元素"></a>5.获取元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#获取元素</span><br>hashTable[<span class="hljs-number">3</span>]<br>mapping[<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取元素</span><br><span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> hashTable[<span class="hljs-number">3</span>];<br>map.get(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="6-检查key是否存在"><a href="#6-检查key是否存在" class="headerlink" title="6.检查key是否存在"></a>6.检查key是否存在</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#检查索引key是否存在</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">in</span> mapping<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//检查key是否存在</span><br>map.containsKey(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="7-哈希表的长度-判空"><a href="#7-哈希表的长度-判空" class="headerlink" title="7.哈希表的长度(判空)"></a>7.哈希表的长度(判空)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#哈希表的长度(判空)</span><br><span class="hljs-built_in">len</span>(mapping)<br><br><span class="hljs-built_in">len</span>(mapping) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//哈希表的长度(判空)</span><br>map.size();<br><br>map.size() == <span class="hljs-number">0</span>;<br>map.isEmpty();<br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>无序性、互异性</p><h3 id="常用操作-5"><a href="#常用操作-5" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1.创建集合"></a>1.创建集合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建集合</span><br>s = <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建集合</span><br>HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="2-添加元素-5"><a href="#2-添加元素-5" class="headerlink" title="2.添加元素"></a>2.添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#添加元素</span><br>s.add(<span class="hljs-number">2</span>)<br>s.add(<span class="hljs-number">3</span>)<br>s.add(<span class="hljs-number">4</span>)<br>s.add(<span class="hljs-number">3</span>)<br><span class="hljs-comment">#&#123;2,3,4&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加元素</span><br>set.add(<span class="hljs-number">3</span>);<br>set.add(<span class="hljs-number">4</span>);<br>set.add(<span class="hljs-number">3</span>);<br>set.add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="3-搜索元素"><a href="#3-搜索元素" class="headerlink" title="3.搜索元素"></a>3.搜索元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#搜索元素</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">in</span> s<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//搜索元素</span><br>set.contains(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#删除元素</span><br>s.remove(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除元素</span><br>set.remove(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h4 id="5-集合的长度"><a href="#5-集合的长度" class="headerlink" title="5.集合的长度"></a>5.集合的长度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#长度O(1)</span><br><span class="hljs-built_in">len</span>(s)<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//长度</span><br>set.size();<br></code></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>节点：每一个元素都是节点</p><p>根结点：一棵树第一层的节点是根节点</p><p>叶子结点：只有父亲节点，没有子节点的节点</p><p>高度：从距离根节点最远的叶子结点开始计算高度，0，1，2，…，n</p><p>深度：从根节点开始计算深度，0，1，2，…，n</p><p>层：从根节点开始计算层数，1，2，…，n</p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>普通二叉树：每个节点最多两个孩子</p><p>满二叉树：除了叶子结点，每个节点都有左右两个孩子且所有叶子结点在同一层上</p><p>完全二叉树：从树的根节点开始，<strong>从上到下，从左到右</strong>，依次填满节点形成的二叉树</p><p><strong>注：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</strong></p><h3 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h3><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p><strong>前序遍历：根节点&gt;&gt;左子树&gt;&gt;右子树</strong></p><p><strong>中序遍历：左子树&gt;&gt;根节点&gt;&gt;右子树</strong></p><p><strong>后序遍历：左子树&gt;&gt;右子树&gt;&gt;根节点</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web前端【更新中】</title>
    <link href="/2019/10/02/Web%E5%89%8D%E7%AB%AF/"/>
    <url>/2019/10/02/Web%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>网站</strong>是指在因特网上根据一定的规则，使用HTML等制作的用于展示特定内容相关的<strong>网页集合</strong>。</p><span id="more"></span><h2 id="HTML基本概念"><a href="#HTML基本概念" class="headerlink" title="HTML基本概念"></a>HTML基本概念</h2><p>视频课：<a href="https://www.bilibili.com/video/BV14J4114768?from=search&amp;seid=6932655716703128049&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV14J4114768?from=search&amp;seid=6932655716703128049&amp;spm_id_from=333.337.0.0</a></p><h3 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h3><p><strong>网站</strong>是指在因特网上根据一定的规则，使用HTML等制作的用于展示特定内容相关的<strong>网页集合</strong>。</p><p><strong>网页</strong>是网站中的一“页”，通常是<strong>HTML格式的文件</strong>，它需要通过<strong>浏览器</strong>来阅读。</p><p><strong>网页</strong>是<strong>构成网站的基本元素</strong>，它通常由<strong>图片、链接、文字、声音、视频等元素组成</strong>。通常我们看到的网页常以<code>.htm</code>或<code>html</code>为后缀结尾的文件，因此称其为<strong>HTML文件</strong>。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><strong>HTML指的是超文本标记语言</strong>（Hyper Text Markup Language），它是描述网页的一种语言。这里，<strong>HTML并不是一种编程语言</strong>，而是一种标记语言（Markup Language），标签语言。</p><h4 id="超文本的含义"><a href="#超文本的含义" class="headerlink" title="超文本的含义"></a>超文本的含义</h4><ol><li><p>它不局限于文本元素，还可以加入图片、声音、动画、多媒体等<strong>超越文本限制</strong>的内容。</p></li><li><p>它可以从一个文件跳转到另外一个文件，与其他文件连接，即<strong>超级链接文本</strong>。</p></li></ol><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><strong>浏览器是网页显示运行的平台</strong>，常用的有IE浏览器、Chrome浏览器、Firefox浏览器、Safari浏览器、Opera浏览器</p><h4 id="浏览器的内核"><a href="#浏览器的内核" class="headerlink" title="浏览器的内核"></a>浏览器的内核</h4><p><strong>浏览器内核</strong>：即<strong>渲染引擎</strong>，负责读取网页的内容，整理计算网页的显示信息，然后呈现网页。</p><table><thead><tr><th align="center">浏览器</th><th>内核</th><th>备注</th></tr></thead><tbody><tr><td align="center">IE</td><td>Trident</td><td>IE、猎豹安全、360极速浏览器、百度浏览器</td></tr><tr><td align="center">Firefox</td><td>Gecko</td><td>火狐浏览器内核</td></tr><tr><td align="center">Safari</td><td>Webkit</td><td>苹果浏览器内核</td></tr><tr><td align="center">Chrome/Opera</td><td>Blink</td><td>Chrome/Opera浏览器内核、Blink其实是Webkit的分支</td></tr></tbody></table><p>注：目前国内浏览器一般采用Webkit/Blink内核，如360、QQ、UC、搜狗等。</p><h3 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>Web标准</strong>是由<strong>W3C组织和其他标准化组织</strong>制定的<strong>一系列标准的集合</strong>。W3C（万维网联盟）是国际最著名的标准组织。</p><h4 id="Web标准的重要性"><a href="#Web标准的重要性" class="headerlink" title="Web标准的重要性"></a>Web标准的重要性</h4><ol><li>网页展示内容样式统一，发展前景广阔</li><li>提高页面浏览速度，便于维护网站</li><li>网站更容易被搜索引擎搜索，降低网站流量费用</li></ol><h4 id="Web标准的构成"><a href="#Web标准的构成" class="headerlink" title="Web标准的构成"></a>Web标准的构成</h4><p>主要由<strong>结构（Structure）</strong>、<strong>表现（Presentation）</strong>和<strong>行为（Behavior）</strong>三方面构成。</p><table><thead><tr><th>标准</th><th>说明</th></tr></thead><tbody><tr><td>结构Structure</td><td>对<strong>网页元素</strong>进行整理和分类，现阶段主要学习HTML</td></tr><tr><td>表现 Presentation</td><td>设置网页元素的<strong>版式、颜色、大小等外观样式</strong>，主要指CSS</td></tr><tr><td>行为Behavior</td><td>网页的<strong>模型定义</strong>以及<strong>交互</strong>，现阶段主要学习JavaScript</td></tr></tbody></table><p>Web标准提出的最佳体验方案：<strong>结构、表现、行为相分离</strong>，即</p><ol><li><p>结构写到HTML文件中</p></li><li><p>表现写到CSS文件中</p></li><li><p>行为写到JavaScript文件中</p></li></ol><p><strong>形象地比喻结构、表现和行为三者的关系：结构即身体骨架，表现即外观装饰，行为即具体动作。</strong></p><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><h3 id="HTML语法规范"><a href="#HTML语法规范" class="headerlink" title="HTML语法规范"></a>HTML语法规范</h3><h4 id="基本语法概述"><a href="#基本语法概述" class="headerlink" title="基本语法概述"></a>基本语法概述</h4><ol><li>HTML标签是由<strong>尖括号包围的关键词</strong>，如<code>&lt;html&gt;</code>。</li><li>HTML标签<strong>通常是成对出现的</strong>，如<code>&lt;html&gt;</code>和<code>&lt;/html&gt;</code>，我们称之为<strong>双标签</strong>。标签对中第一个标签我们称为<strong>开始标签</strong>，第二个标签称为<strong>结束标签</strong>。</li><li>有些特殊的极少数标签必须是<strong>单个标签</strong>，如<code>&lt;br /&gt;</code><strong>（<code>/</code>之前通常加个空格 )**，我们称之为</strong>单标签**。</li></ol><h4 id="标签关系"><a href="#标签关系" class="headerlink" title="标签关系"></a>标签关系</h4><p><strong>双标签关系</strong>可以分为两类：<strong>包含关系</strong>和并<strong>列关系</strong>。</p><ol><li><p>包含关系（像父子一样的从属关系）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时，<code>&lt;head&gt;</code>标签包含<code>&lt;title&gt;</code>标签。</p></li><li><p>并列关系（相兄弟一样的平等关系）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时，<code>&lt;head&gt;</code>标签和<code>&lt;body&gt;</code>标签并列。</p></li></ol><h3 id="HTML基本结构标签"><a href="#HTML基本结构标签" class="headerlink" title="HTML基本结构标签"></a>HTML基本结构标签</h3><h4 id="第一个HTML网页"><a href="#第一个HTML网页" class="headerlink" title="第一个HTML网页"></a>第一个HTML网页</h4><p>每一个网页都会有一个基本的结构标签，也称为骨架标签，页面内容也就是在这些基本标签上书写。因此，HTML页面也称为HTML文档。</p><table><thead><tr><th align="center">标签名</th><th align="center">定义</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><html></html></td><td align="center">HTML标签</td><td align="center">页面中最大的标签，我们称为<strong>根标签</strong>。</td></tr><tr><td align="center"><head></head></td><td align="center">文档的头部</td><td align="center"><strong>在head标签中必须设置title标签</strong>。</td></tr><tr><td align="center"><title></title></td><td align="center">文档的标签</td><td align="center">让页面拥有一个属于自己的标签。</td></tr><tr><td align="center"><body></body></td><td align="center">文档的主体</td><td align="center">元素包含文档的所有内容，页面内容基本都是放在body标签里面的。</td></tr></tbody></table><p><img src="Web%E5%89%8D%E7%AB%AF/008i3skNly1gv16sv0m4vj61rm0iqq4y02.jpg"></p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    键盘敲烂，工资过万！<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>首推VScode。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ol><li>新建文件（Ctrl + N）</li><li>保存（Ctrl + N），文件后缀：<code>.html</code></li><li>输入感叹号<code>!</code>，按下<code>Tab</code>按键，自动生成页面骨架文件</li><li>Ctrl + <code>+</code>和Ctrl + <code> -</code> 可以缩放视图</li><li>利用插件预览页面：右键，选择<code>Open In Default Browser</code></li></ol><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ol><li>汉化包：Chinese (Simplified) Language Pack for VS Code</li><li>浏览器预览：Open In Brower</li><li>自动重命名匹配标签：Auto Rename Tag</li><li>追踪样式：CSS Peek</li></ol><h4 id="骨架标签中的新增代码"><a href="#骨架标签中的新增代码" class="headerlink" title="骨架标签中的新增代码"></a>骨架标签中的新增代码</h4><p>输入感叹号<code>!</code>，按下<code>Tab</code>按键，自动生成页面骨架文件如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的第一个页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    键盘敲烂，月入过万！<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新增了&lt;!DOCTYPE&gt;标签、lang语言、 charset字符集</p><ol><li><p><code>&lt;!DOCTYPE&gt;</code>标签：文档类型生命标签，它的作用是告诉浏览器使用哪种HTML版本来显示网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这句代码的意思是说：当前网页页面采用的是HTML5版本来显示网页。</p><p><strong>注意：<code>&lt;!DOCTYPE&gt;</code>声明位于所有代码的最前面，即在<code>&lt;html&gt;</code>标签之前。但它不是HTML标签，只是一个文档类型声明标签。</strong></p></li><li><p>lang语言种类：用来定义当前文档显示的语言</p><ol><li><code>en</code>为英语，即英文网页</li><li><code>zh-CN</code>为中文，即中文网页</li></ol><p>当然，定义为<code>en</code>也可以显示中文，定义为<code>zh-CN</code>也可以显示英文。</p></li><li><p>charset字符集：它是多个字符的集合，以便计算机可以识别和存储各种文字。在<code>&lt;head&gt;</code>标签内，可以通过<code>&lt;meta&gt;</code>标签的<code>charset</code>属性来规定HTML文档应该使用哪种字符编码。如：</p></li><li><pre><code class="html">&lt;meta charset = &quot;utf-8&quot; /&gt;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   常用的charset字符集的值有：`GB2312`、`BIG5`、`GBK`和`UTF-<span class="hljs-number">8</span>`。其中，`UTF-<span class="hljs-number">8</span>`也被称为万国码，基本包含了全世界所有国家需要用到的字符。<br><br>### HTML常用标签<br><br>#### 标题标签<br><br>标题标签从&lt;h1&gt;-&lt;h6&gt;，作为标题使用，并且依据重要性递减。其中，h是head的缩写。如：<br><br>```html<br>&lt;h1&gt;<br>  我是一级标题<br>&lt;/h1&gt;<br>&lt;h3&gt;<br>  我是三级标题<br>&lt;/h3&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ol><p>特点：加入标题标签的文字会加粗，字号也会增大，并且该文字会独占一行。</p><p>后有诗赞曰：<strong>标题一共六级选，文字加粗一行显。</strong></p><p>​                        <strong>由大到小依次减，从重到轻随之变。</strong></p><p>​                        <strong>语法规范书写后，具体效果刷新见。</strong></p><h4 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h4><p>在HTML标签中，<p>标签用于定义段落，将网页文字分段显示。其中，p是paragraph的缩写。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  我是一个段落标签<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>特点：一个段落的文本会根据浏览器的窗口大小进行自适应换行，不同段落之间会有较大的空隙。</p><h4 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h4><p>在HTML中，一个段落的文字会从左向右依次排列直到浏览器的右端，然后根据浏览器的窗口大小自适应自动换行显示。如果希望自定义换行位置，则需要用换行标签<code>&lt;br /&gt;</code>来强制换行显示。其中，br是break的缩写。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">我是一个<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>换行标签<br></code></pre></td></tr></table></figure><p>特点：<code>&lt;br /&gt;</code>是一个单标签，它只是简单的强制换行显示，与<p>标签不同，<p>标签分段，段落与段落之间有一个明显的垂直间距。</p><h4 id="盒子标签"><a href="#盒子标签" class="headerlink" title="盒子标签"></a>盒子标签</h4><p>在HTML中，盒子标签有<div></div>和<span></span>。它们是没有语义的用来装内容的盒子。其中，div是division的缩写，表示分割、分区；span表示跨度、跨距。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  我是一个div标签<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是一个span标签<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>特点：<div></div>标签用来布局，使用该标签的内容会独占一行，即大盒子。<span></span>标签用来布局，一行上可以存在多个<span></span>，即小盒子。</p><h4 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h4><p>在HTML中，<img>标签用于定义引用HTML页面中的图像。其中，img是image的缩写。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;图像URL&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>特点：src是<img>标签的必须属性（凡是出现<img>标签，必须有src属性），用于指定引用图像文件的路径和文件的名称。</p><p>属性：属于这个标签的特性。</p><p><img>标签的其他属性如下：</p><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">src</td><td align="center">图片路径</td><td align="center">必须属性</td></tr><tr><td align="center">alt</td><td align="center">文本</td><td align="center">替换文本。图像不能显示时，显示的文字</td></tr><tr><td align="center">title</td><td align="center">文本</td><td align="center">提示文本。鼠标放到图像上时，显示的文字</td></tr><tr><td align="center">width</td><td align="center">像素</td><td align="center">设置图像的宽度</td></tr><tr><td align="center">height</td><td align="center">像素</td><td align="center">设置图像的高度</td></tr><tr><td align="center">border</td><td align="center">像素</td><td align="center">设置图像的边框粗细</td></tr></tbody></table><p>注：通常图像的宽度和高度设置一个值即可，另外一个属性值会等比例缩放。</p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>路径通常分为<strong>绝对路径</strong>和<strong>相对路径</strong>。</p><p>绝对路径：指的是目录下的绝对位置，直接达到目标位置，通常是指从盘符开始的路径。例如：<code>D:\web\img\1.jpg</code>或网络地址<code>http://www.xxx.cn/img/1.jpg</code>。</p><p>相对路径：以<strong>引用文件所在位置</strong>为参考而建立的目录路径。即，<strong>图片相对于HTML页面的位置</strong>。</p><p>相对路径分为以下三类：</p><table><thead><tr><th align="center">分类</th><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">同一级路径</td><td align="center"></td><td align="center">图像位于HTML文件同一级，如<code>&lt;img src=&quot;1.jpg&quot; /&gt;</code></td></tr><tr><td align="center">下一级路径</td><td align="center">/</td><td align="center">图像位于HTML文件下一级，如<code>&lt;img src=&quot;imgs/1.jpg&quot; /&gt;</code></td></tr><tr><td align="center">上一级路径</td><td align="center">../</td><td align="center">图像位于HTML文件上一级，如<code>&lt;img src=&quot;../1.jpg&quot; /&gt;</code></td></tr></tbody></table><h4 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h4><p>在HTML中，<a>标签用于定义超链接，作用是从一个页面链接到另一个页面。其中，a是anchor的缩写，意为锚。</p><ol><li><p>链接的语法格式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;跳转目标&quot;</span> <span class="hljs-attr">target</span> = <span class="hljs-string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span><br>文本或图像<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a>标签的属性表：</p><table><thead><tr><th align="center">属性</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">href</td><td align="left">指定链接目标的URL地址，<strong>它是<a>的必须属性</strong>，使文本或图像具有超链接的功能。</td></tr><tr><td align="center">target</td><td align="left">指定链接页面的打开方式，其中_self为在当前窗口打开页面（默认值），__blank为在新窗口中打开</td></tr></tbody></table></li><li><p>链接的分类</p><ol><li><p>外部链接：链接到互联网上其他的网址，目标URL地址必须带<code>http://</code>或者<code>https://</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>百度http<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>百度https<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;www.baidu.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>前两个<a>标签可以跳转至百度网址，第三个<a>标签无法跳转。</p></li><li><p>内部链接：链接到本地的其他HTML文件，目标URL地址是HTML的文件路径即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;我的第一个页面.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>内部链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>空链接：如果当前暂时没有链接目标时，可以用<code>#</code>暂时代替目标地址URL。有超链接效果，跳转至当前页面（或者说并未发生跳转）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>空链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>下载链接：如果href的地址是一个文件或者是压缩包，则会下载该文件（压缩包），如<code>.exe</code>、<code>.zip</code>等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;img.zip&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>下载链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>网页元素链接：在网页中，文本、图像、表格、音频、视频等元素都可以添加超链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.qq.com&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;img.jpg&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>锚点链接：点击链接元素，可以快速定位到当前页面的某个位置。需要事先根据需求设置锚点位置，然后再设置超链接即可。</p><p>i. 在目标位置所在的标签里添加<code>id</code>属性，设置锚点，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;anchor&quot;</span>&gt;</span>锚点<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ii. 在链接文本的href属性中，设置属性值为<code>#anchor</code>的形式，如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#anchor&quot;</span>&gt;</span>跳转至锚点<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设，<code>跳转至锚点</code>链接文本在页面顶部，<code>锚点</code>位置在页面底部。点击<code>跳转至锚点</code>链接文本，当前页面会迅速定位到页面底部<code>锚点</code>位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#anchor&quot;</span>&gt;</span>跳转至锚点<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;anchor&quot;</span>&gt;</span>锚点<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h4><p>在HTML中，注释的标签符号为以<code>&lt;!--</code>开始，以<code>--&gt;</code>结束，中间的内容即可被注释。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--  我被注释了 --&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  注释语句 --&gt;</span>快捷键：ctrl + /<br></code></pre></td></tr></table></figure><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>在HTML中，有一个特殊字符需要用一些代码表示，如下：</p><p><img src="Web%E5%89%8D%E7%AB%AF/008i3skNly1gv16u6txfoj61q40sawiw02.jpg"></p><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><p>表格主要用于规整地显示、展示数据，增强数据的可读性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格内的文字<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p> <code>&lt;table&gt;&lt;/table&gt;</code>标签是用于定义表格的标签。</p></li><li><p><code>&lt;tr&gt;&lt;/tr&gt;</code>标签是用于定义表格中的行，必须嵌套在<code>&lt;table&gt;&lt;/table&gt;</code>标签中，tr即table row的缩写，意为表格的行。</p></li><li><p><code>&lt;td&gt;&lt;/td&gt;</code>标签用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中，td即table data的缩写，意为数据单元格的内容。</p></li><li><p>表格快捷键：<code>table&gt;tr&gt;td</code></p><p>n行m列快捷键：<code>table&gt;tr*n&gt;td*m</code></p></li></ol><p>表头单元格标签</p><p>一般表头单元格位于表格的第一行或者第一列，表头单元格的文本内容加粗居中显示。</p><p><code>&lt;th&gt;</code>标签表示HTML表格的表头部分（即table head的缩写）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>顾钧<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>13<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>乐乐<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>32<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>表格属性</p><p>表格标签的属性不常用，后面CSS课程会讲到，这里只做了解。下列标签属性要写在表格标签<table>里面</p><table><thead><tr><th align="center">属性名</th><th align="center">属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">align</td><td align="center">left、right、center</td><td align="center">规定表格相对于周围元素的对齐方式</td></tr><tr><td align="center">border</td><td align="center">1、””</td><td align="center">1表示有边框，””表示无边框，默认为 “”</td></tr><tr><td align="center">cellpadding</td><td align="center">像素值</td><td align="center">单元边沿与其内容之间的空白，默认为1像素</td></tr><tr><td align="center">cellspacing</td><td align="center">像素值</td><td align="center">单元格之间的空白，默认为2像素</td></tr><tr><td align="center">width</td><td align="center">像素值或百分比</td><td align="center">规定表格的宽度</td></tr><tr><td align="center">height</td><td align="center">像素值或百分比</td><td align="center">规定表格的宽度</td></tr></tbody></table><p>表格结构标签</p><p>如果我们遇到表格太长的情况，可以将表格分为<strong>表格头部</strong>和<strong>表格主体</strong>两大部分。在表格标签中，分别用：<code>&lt;thead&gt;</code>表示表格头部区域，<code>&lt;tbody&gt;</code>表示表格主体区域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>顾钧<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>13<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>乐乐<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>32<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>合并单元格</p><p>在制作简历等情况下，我们需要合并单元格，使表格更加规整美观。</p><p>合并单元格的方式：</p><ul><li><p>跨行合并：rowspan=”合并单元格的个数”</p></li><li><p>跨列合并：colspan=”合并单元格的个数”</p></li><li><p>目标单元格：用来书写合并代码。</p><p>​            跨行：以最上侧的单元格为目标单元格，书写合并代码</p><p>​            跨列：以最左侧的单元格为目标单元格，书写合并代码</p></li></ul><p>合并单元格的步骤：</p><ol><li>确定合并单元格的方式：跨行 or 跨列</li><li>找到目标单元格，书写合并代码</li><li>删除多余的单元格</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
